<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SESIÓN 4: Networking y Sockets</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>SESIÓN 4: Networking y Sockets</div>
    </header>

    <section class="contenido-didactico">
        <h1>BLOQUE 1: Fundamentos de Sockets</h1>

        <h2>1.1 Conceptos de Red: TCP vs UDP</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Conceptos fundamentales de redes para programación con sockets
"""

# ========================================
# CONCEPTOS TEÓRICOS
# ========================================

"""
MODELO CLIENTE-SERVIDOR
=======================
- Servidor: Escucha en un puerto, espera conexiones
- Cliente: Inicia la conexión hacia el servidor

DIRECCIONES Y PUERTOS
=====================
- Dirección IP: Identifica un host en la red (ej: 192.168.1.100)
- Puerto: Identifica un servicio/aplicación (0-65535)
  - Puertos bien conocidos: 0-1023 (requieren root)
  - Puertos registrados: 1024-49151
  - Puertos dinámicos: 49152-65535

PUERTOS COMUNES
===============
21   - FTP
22   - SSH
23   - Telnet
25   - SMTP
53   - DNS
80   - HTTP
110  - POP3
143  - IMAP
443  - HTTPS
445  - SMB
3306 - MySQL
3389 - RDP
5432 - PostgreSQL
6379 - Redis
8080 - HTTP alternativo

TCP (Transmission Control Protocol)
===================================
- Orientado a conexión (handshake de 3 vías)
- Garantiza entrega ordenada de datos
- Control de flujo y congestión
- Más lento pero confiable
- Usado por: HTTP, SSH, FTP, SMTP

Handshake TCP:
1. Cliente → SYN → Servidor
2. Cliente ← SYN-ACK ← Servidor  
3. Cliente → ACK → Servidor
4. Conexión establecida

UDP (User Datagram Protocol)
============================
- Sin conexión (connectionless)
- No garantiza entrega ni orden
- Sin control de flujo
- Más rápido pero no confiable
- Usado por: DNS, DHCP, VoIP, streaming, juegos

SOCKETS
=======
Un socket es un endpoint de comunicación bidireccional.
Combinación de: IP + Puerto + Protocolo
"""

# Diccionario de puertos comunes para referencia
PUERTOS_COMUNES = {
    21: ("FTP", "File Transfer Protocol"),
    22: ("SSH", "Secure Shell"),
    23: ("Telnet", "Telnet (inseguro)"),
    25: ("SMTP", "Simple Mail Transfer Protocol"),
    53: ("DNS", "Domain Name System"),
    80: ("HTTP", "Hypertext Transfer Protocol"),
    110: ("POP3", "Post Office Protocol v3"),
    111: ("RPC", "Remote Procedure Call"),
    135: ("MSRPC", "Microsoft RPC"),
    139: ("NetBIOS", "NetBIOS Session Service"),
    143: ("IMAP", "Internet Message Access Protocol"),
    443: ("HTTPS", "HTTP Secure"),
    445: ("SMB", "Server Message Block"),
    993: ("IMAPS", "IMAP Secure"),
    995: ("POP3S", "POP3 Secure"),
    1433: ("MSSQL", "Microsoft SQL Server"),
    1521: ("Oracle", "Oracle Database"),
    3306: ("MySQL", "MySQL Database"),
    3389: ("RDP", "Remote Desktop Protocol"),
    5432: ("PostgreSQL", "PostgreSQL Database"),
    5900: ("VNC", "Virtual Network Computing"),
    6379: ("Redis", "Redis Database"),
    8080: ("HTTP-Alt", "HTTP Alternativo"),
    8443: ("HTTPS-Alt", "HTTPS Alternativo"),
    27017: ("MongoDB", "MongoDB Database"),
}

def obtener_info_puerto(puerto):
    """Retorna información sobre un puerto conocido."""
    if puerto in PUERTOS_COMUNES:
        nombre, descripcion = PUERTOS_COMUNES[puerto]
        return f"{puerto}/{nombre}: {descripcion}"
    return f"{puerto}: Puerto no catalogado"

# Mostrar puertos comunes
print("=== PUERTOS COMUNES EN CIBERSEGURIDAD ===\n")
for puerto in sorted(PUERTOS_COMUNES.keys())[:15]:
    print(f"  {obtener_info_puerto(puerto)}")</code></pre>

        <h2>1.2 Módulo socket: Creación de Sockets</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo socket: fundamentos de creación de sockets
"""

import socket

# ========================================
# CREACIÓN DE SOCKETS
# ========================================

print("=== FUNDAMENTOS DEL MÓDULO SOCKET ===\n")

"""
socket.socket(family, type, proto)

Family (Familia de direcciones):
- socket.AF_INET   : IPv4
- socket.AF_INET6  : IPv6
- socket.AF_UNIX   : Sockets Unix (comunicación local)

Type (Tipo de socket):
- socket.SOCK_STREAM : TCP (flujo de bytes confiable)
- socket.SOCK_DGRAM  : UDP (datagramas)
- socket.SOCK_RAW    : Acceso directo a protocolos de red

Proto (Protocolo):
- Generalmente 0 (selección automática)
"""

# Crear socket TCP/IPv4
socket_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print(f"[+] Socket TCP creado: {socket_tcp}")

# Crear socket UDP/IPv4
socket_udp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
print(f"[+] Socket UDP creado: {socket_udp}")

# Cerrar sockets (importante para liberar recursos)
socket_tcp.close()
socket_udp.close()
print("[+] Sockets cerrados")

# ========================================
# OPCIONES DE SOCKET
# ========================================

print("\n=== OPCIONES DE SOCKET ===\n")

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Reutilizar dirección (evita "Address already in use")
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
print("[+] SO_REUSEADDR habilitado")

# Configurar timeout (segundos)
sock.settimeout(5.0)
print(f"[+] Timeout configurado: {sock.gettimeout()} segundos")

# Timeout bloqueante vs no bloqueante
# sock.setblocking(False)  # No bloqueante
# sock.setblocking(True)   # Bloqueante (default)

sock.close()

# ========================================
# RESOLUCIÓN DNS
# ========================================

print("\n=== RESOLUCIÓN DNS ===\n")

# Obtener IP de un hostname
try:
    ip = socket.gethostbyname("google.com")
    print(f"google.com -> {ip}")
except socket.gaierror as e:
    print(f"Error de resolución: {e}")

# Obtener todas las IPs (pueden ser varias)
try:
    resultado = socket.gethostbyname_ex("google.com")
    hostname, aliases, ips = resultado
    print(f"\nHostname: {hostname}")
    print(f"Aliases: {aliases}")
    print(f"IPs: {ips}")
except socket.gaierror as e:
    print(f"Error: {e}")

# Resolución inversa (IP a hostname)
try:
    hostname, aliases, ips = socket.gethostbyaddr("8.8.8.8")
    print(f"\n8.8.8.8 -> {hostname}")
except socket.herror as e:
    print(f"Error de resolución inversa: {e}")

# Información del host local
print(f"\nHostname local: {socket.gethostname()}")
try:
    ip_local = socket.gethostbyname(socket.gethostname())
    print(f"IP local: {ip_local}")
except:
    print("No se pudo resolver IP local")

# Obtener FQDN
print(f"FQDN: {socket.getfqdn()}")

# ========================================
# INFORMACIÓN DE SERVICIOS
# ========================================

print("\n=== INFORMACIÓN DE SERVICIOS ===\n")

# Puerto a nombre de servicio
servicios = [22, 80, 443, 21, 25, 3306]
for puerto in servicios:
    try:
        nombre = socket.getservbyport(puerto, 'tcp')
        print(f"Puerto {puerto} -> {nombre}")
    except:
        print(f"Puerto {puerto} -> desconocido")

# Nombre de servicio a puerto
print()
for servicio in ['ssh', 'http', 'https', 'ftp']:
    try:
        puerto = socket.getservbyname(servicio, 'tcp')
        print(f"{servicio} -> Puerto {puerto}")
    except:
        print(f"{servicio} -> desconocido")</code></pre>

        <h2>1.3 Sockets TCP: Cliente y Servidor</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Sockets TCP: Operaciones fundamentales
"""

import socket

# ========================================
# MÉTODOS PRINCIPALES TCP
# ========================================

"""
SERVIDOR TCP:
1. socket()    - Crear socket
2. bind()      - Asociar a IP:Puerto
3. listen()    - Escuchar conexiones
4. accept()    - Aceptar conexión entrante
5. recv/send   - Recibir/Enviar datos
6. close()     - Cerrar conexión

CLIENTE TCP:
1. socket()    - Crear socket
2. connect()   - Conectar al servidor
3. send/recv   - Enviar/Recibir datos
4. close()     - Cerrar conexión
"""

# ========================================
# SERVIDOR TCP BÁSICO
# ========================================

def servidor_tcp_simple(host='127.0.0.1', puerto=9999):
    """
    Servidor TCP básico que acepta una conexión.
    """
    # Crear socket TCP
    servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # Permitir reutilizar la dirección
    servidor.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        # Asociar a dirección y puerto
        servidor.bind((host, puerto))
        print(f"[*] Servidor enlazado a {host}:{puerto}")
        
        # Escuchar conexiones (backlog=5: cola de conexiones pendientes)
        servidor.listen(5)
        print(f"[*] Escuchando conexiones...")
        
        # Aceptar conexión (bloqueante)
        # Retorna: (socket_cliente, (ip_cliente, puerto_cliente))
        cliente_socket, direccion = servidor.accept()
        print(f"[+] Conexión recibida de {direccion[0]}:{direccion[1]}")
        
        # Recibir datos (máximo 1024 bytes)
        datos = cliente_socket.recv(1024)
        print(f"[+] Datos recibidos: {datos.decode('utf-8')}")
        
        # Enviar respuesta
        respuesta = "Mensaje recibido correctamente"
        cliente_socket.send(respuesta.encode('utf-8'))
        print(f"[+] Respuesta enviada")
        
        # Cerrar conexión del cliente
        cliente_socket.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        servidor.close()
        print("[*] Servidor cerrado")


# ========================================
# CLIENTE TCP BÁSICO
# ========================================

def cliente_tcp_simple(host='127.0.0.1', puerto=9999, mensaje="Hola servidor"):
    """
    Cliente TCP básico que envía un mensaje.
    """
    # Crear socket TCP
    cliente = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Configurar timeout
        cliente.settimeout(10)
        
        # Conectar al servidor
        cliente.connect((host, puerto))
        print(f"[+] Conectado a {host}:{puerto}")
        
        # Enviar mensaje
        cliente.send(mensaje.encode('utf-8'))
        print(f"[+] Mensaje enviado: {mensaje}")
        
        # Recibir respuesta
        respuesta = cliente.recv(1024)
        print(f"[+] Respuesta: {respuesta.decode('utf-8')}")
        
    except socket.timeout:
        print("[-] Timeout de conexión")
    except socket.error as e:
        print(f"[-] Error de socket: {e}")
    finally:
        cliente.close()
        print("[*] Conexión cerrada")


# ========================================
# SERVIDOR TCP CON MÚLTIPLES MENSAJES
# ========================================

def servidor_tcp_interactivo(host='127.0.0.1', puerto=9999):
    """
    Servidor que mantiene conexión para múltiples mensajes.
    """
    servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    servidor.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        servidor.bind((host, puerto))
        servidor.listen(5)
        print(f"[*] Servidor escuchando en {host}:{puerto}")
        
        cliente_socket, direccion = servidor.accept()
        print(f"[+] Cliente conectado: {direccion}")
        
        # Enviar banner
        cliente_socket.send(b"=== Bienvenido al servidor ===\n")
        
        while True:
            datos = cliente_socket.recv(1024)
            
            if not datos:
                print("[-] Cliente desconectado")
                break
            
            mensaje = datos.decode('utf-8').strip()
            print(f"[CLIENTE] {mensaje}")
            
            if mensaje.lower() == 'exit':
                cliente_socket.send(b"Adios!\n")
                break
            
            # Echo: responder con el mismo mensaje
            respuesta = f"Echo: {mensaje}\n"
            cliente_socket.send(respuesta.encode('utf-8'))
        
        cliente_socket.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        servidor.close()


# ========================================
# EJEMPLO DE USO
# ========================================

if __name__ == "__main__":
    print("=== SOCKETS TCP ===\n")
    print("Para probar, ejecuta en terminales separadas:")
    print("  Terminal 1 (servidor): python script.py servidor")
    print("  Terminal 2 (cliente):  python script.py cliente")
    print("\nO usa netcat:")
    print("  nc localhost 9999")
    
    import sys
    if len(sys.argv) > 1:
        if sys.argv[1] == "servidor":
            servidor_tcp_interactivo()
        elif sys.argv[1] == "cliente":
            cliente_tcp_simple(mensaje="Hola desde el cliente!")</code></pre>

        <h2>1.4 Sockets UDP</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Sockets UDP: comunicación sin conexión
"""

import socket

# ========================================
# UDP vs TCP
# ========================================

"""
UDP NO tiene:
- Conexión establecida (no connect obligatorio)
- Garantía de entrega
- Orden de paquetes
- Control de flujo

UDP usa:
- sendto(datos, (ip, puerto))  - Enviar
- recvfrom(tamaño)             - Recibir (retorna datos y dirección)

Casos de uso:
- DNS (consultas rápidas)
- Streaming de video/audio
- Juegos online
- SNMP, TFTP, DHCP
"""

# ========================================
# SERVIDOR UDP
# ========================================

def servidor_udp(host='127.0.0.1', puerto=9999):
    """Servidor UDP simple."""
    servidor = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    try:
        servidor.bind((host, puerto))
        print(f"[*] Servidor UDP escuchando en {host}:{puerto}")
        
        while True:
            # Recibir datos y dirección del cliente
            datos, direccion = servidor.recvfrom(1024)
            mensaje = datos.decode('utf-8')
            print(f"[{direccion[0]}:{direccion[1]}] {mensaje}")
            
            if mensaje.strip().lower() == 'exit':
                break
            
            # Responder al cliente
            respuesta = f"Recibido: {mensaje}"
            servidor.sendto(respuesta.encode('utf-8'), direccion)
    
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        servidor.close()
        print("[*] Servidor cerrado")


# ========================================
# CLIENTE UDP
# ========================================

def cliente_udp(host='127.0.0.1', puerto=9999, mensaje="Hola UDP"):
    """Cliente UDP simple."""
    cliente = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    try:
        cliente.settimeout(5)
        
        # Enviar mensaje (no requiere connect previo)
        cliente.sendto(mensaje.encode('utf-8'), (host, puerto))
        print(f"[+] Mensaje enviado a {host}:{puerto}")
        
        # Recibir respuesta
        datos, servidor = cliente.recvfrom(1024)
        print(f"[+] Respuesta de {servidor}: {datos.decode('utf-8')}")
        
    except socket.timeout:
        print("[-] Timeout esperando respuesta")
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        cliente.close()


# ========================================
# EJEMPLO: CONSULTA DNS SIMPLE
# ========================================

def consulta_dns_raw(dominio, servidor_dns='8.8.8.8'):
    """
    Ejemplo simplificado de consulta DNS sobre UDP.
    (En producción usar dnspython o resolver del sistema)
    """
    import struct
    import random
    
    # Construir consulta DNS básica
    transaction_id = random.randint(0, 65535)
    
    # Header DNS
    flags = 0x0100  # Recursión deseada
    questions = 1
    header = struct.pack('>HHHHHH', 
                        transaction_id, flags, questions, 0, 0, 0)
    
    # Question section
    question = b''
    for parte in dominio.split('.'):
        question += bytes([len(parte)]) + parte.encode()
    question += b'\x00'  # Fin del nombre
    question += struct.pack('>HH', 1, 1)  # Type A, Class IN
    
    consulta = header + question
    
    # Enviar consulta UDP
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(5)
    
    try:
        sock.sendto(consulta, (servidor_dns, 53))
        respuesta, _ = sock.recvfrom(512)
        
        # Parsear respuesta (simplificado)
        if len(respuesta) > 12:
            answers = struct.unpack('>H', respuesta[6:8])[0]
            print(f"[+] Consulta DNS para {dominio}")
            print(f"    Servidor: {servidor_dns}")
            print(f"    Respuestas: {answers}")
            print(f"    Tamaño respuesta: {len(respuesta)} bytes")
        
    except socket.timeout:
        print("[-] Timeout en consulta DNS")
    finally:
        sock.close()


if __name__ == "__main__":
    print("=== SOCKETS UDP ===\n")
    
    # Demostrar consulta DNS
    consulta_dns_raw("google.com")</code></pre>
    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>