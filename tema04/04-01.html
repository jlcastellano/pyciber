<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SESIÓN 4: Networking y Sockets</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>SESIÓN 4: Networking y Sockets</div>
    </header>

    <section class="contenido-didactico">
        <h1>BLOQUE 1: Fundamentos de Sockets</h1>

        <h2>1.1 Conceptos de Red: TCP vs UDP</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Conceptos fundamentales de redes para programación con sockets
"""

# ========================================
# CONCEPTOS TEÓRICOS
# ========================================

"""
MODELO CLIENTE-SERVIDOR
=======================
- Servidor: Escucha en un puerto, espera conexiones
- Cliente: Inicia la conexión hacia el servidor

DIRECCIONES Y PUERTOS
=====================
- Dirección IP: Identifica un host en la red (ej: 192.168.1.100)
- Puerto: Identifica un servicio/aplicación (0-65535)
  - Puertos bien conocidos: 0-1023 (requieren root)
  - Puertos registrados: 1024-49151
  - Puertos dinámicos: 49152-65535

PUERTOS COMUNES
===============
21   - FTP
22   - SSH
23   - Telnet
25   - SMTP
53   - DNS
80   - HTTP
110  - POP3
143  - IMAP
443  - HTTPS
445  - SMB
3306 - MySQL
3389 - RDP
5432 - PostgreSQL
6379 - Redis
8080 - HTTP alternativo

TCP (Transmission Control Protocol)
===================================
- Orientado a conexión (handshake de 3 vías)
- Garantiza entrega ordenada de datos
- Control de flujo y congestión
- Más lento pero confiable
- Usado por: HTTP, SSH, FTP, SMTP

Handshake TCP:
1. Cliente → SYN → Servidor
2. Cliente ← SYN-ACK ← Servidor  
3. Cliente → ACK → Servidor
4. Conexión establecida

UDP (User Datagram Protocol)
============================
- Sin conexión (connectionless)
- No garantiza entrega ni orden
- Sin control de flujo
- Más rápido pero no confiable
- Usado por: DNS, DHCP, VoIP, streaming, juegos

SOCKETS
=======
Un socket es un endpoint de comunicación bidireccional.
Combinación de: IP + Puerto + Protocolo
"""

# Diccionario de puertos comunes para referencia
PUERTOS_COMUNES = {
    21: ("FTP", "File Transfer Protocol"),
    22: ("SSH", "Secure Shell"),
    23: ("Telnet", "Telnet (inseguro)"),
    25: ("SMTP", "Simple Mail Transfer Protocol"),
    53: ("DNS", "Domain Name System"),
    80: ("HTTP", "Hypertext Transfer Protocol"),
    110: ("POP3", "Post Office Protocol v3"),
    111: ("RPC", "Remote Procedure Call"),
    135: ("MSRPC", "Microsoft RPC"),
    139: ("NetBIOS", "NetBIOS Session Service"),
    143: ("IMAP", "Internet Message Access Protocol"),
    443: ("HTTPS", "HTTP Secure"),
    445: ("SMB", "Server Message Block"),
    993: ("IMAPS", "IMAP Secure"),
    995: ("POP3S", "POP3 Secure"),
    1433: ("MSSQL", "Microsoft SQL Server"),
    1521: ("Oracle", "Oracle Database"),
    3306: ("MySQL", "MySQL Database"),
    3389: ("RDP", "Remote Desktop Protocol"),
    5432: ("PostgreSQL", "PostgreSQL Database"),
    5900: ("VNC", "Virtual Network Computing"),
    6379: ("Redis", "Redis Database"),
    8080: ("HTTP-Alt", "HTTP Alternativo"),
    8443: ("HTTPS-Alt", "HTTPS Alternativo"),
    27017: ("MongoDB", "MongoDB Database"),
}

def obtener_info_puerto(puerto):
    """Retorna información sobre un puerto conocido."""
    if puerto in PUERTOS_COMUNES:
        nombre, descripcion = PUERTOS_COMUNES[puerto]
        return f"{puerto}/{nombre}: {descripcion}"
    return f"{puerto}: Puerto no catalogado"

# Mostrar puertos comunes
print("=== PUERTOS COMUNES EN CIBERSEGURIDAD ===\n")
for puerto in sorted(PUERTOS_COMUNES.keys())[:15]:
    print(f"  {obtener_info_puerto(puerto)}")</code></pre>

        <h2>1.2 Módulo socket: Creación de Sockets</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo socket: fundamentos de creación de sockets
"""

import socket

# ========================================
# CREACIÓN DE SOCKETS
# ========================================

print("=== FUNDAMENTOS DEL MÓDULO SOCKET ===\n")

"""
socket.socket(family, type, proto)

Family (Familia de direcciones):
- socket.AF_INET   : IPv4
- socket.AF_INET6  : IPv6
- socket.AF_UNIX   : Sockets Unix (comunicación local)

Type (Tipo de socket):
- socket.SOCK_STREAM : TCP (flujo de bytes confiable)
- socket.SOCK_DGRAM  : UDP (datagramas)
- socket.SOCK_RAW    : Acceso directo a protocolos de red

Proto (Protocolo):
- Generalmente 0 (selección automática)
"""

# Crear socket TCP/IPv4
socket_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print(f"[+] Socket TCP creado: {socket_tcp}")

# Crear socket UDP/IPv4
socket_udp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
print(f"[+] Socket UDP creado: {socket_udp}")

# Cerrar sockets (importante para liberar recursos)
socket_tcp.close()
socket_udp.close()
print("[+] Sockets cerrados")

# ========================================
# OPCIONES DE SOCKET
# ========================================

print("\n=== OPCIONES DE SOCKET ===\n")

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Reutilizar dirección (evita "Address already in use")
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
print("[+] SO_REUSEADDR habilitado")

# Configurar timeout (segundos)
sock.settimeout(5.0)
print(f"[+] Timeout configurado: {sock.gettimeout()} segundos")

# Timeout bloqueante vs no bloqueante
# sock.setblocking(False)  # No bloqueante
# sock.setblocking(True)   # Bloqueante (default)

sock.close()

# ========================================
# RESOLUCIÓN DNS
# ========================================

print("\n=== RESOLUCIÓN DNS ===\n")

# Obtener IP de un hostname
try:
    ip = socket.gethostbyname("google.com")
    print(f"google.com -> {ip}")
except socket.gaierror as e:
    print(f"Error de resolución: {e}")

# Obtener todas las IPs (pueden ser varias)
try:
    resultado = socket.gethostbyname_ex("google.com")
    hostname, aliases, ips = resultado
    print(f"\nHostname: {hostname}")
    print(f"Aliases: {aliases}")
    print(f"IPs: {ips}")
except socket.gaierror as e:
    print(f"Error: {e}")

# Resolución inversa (IP a hostname)
try:
    hostname, aliases, ips = socket.gethostbyaddr("8.8.8.8")
    print(f"\n8.8.8.8 -> {hostname}")
except socket.herror as e:
    print(f"Error de resolución inversa: {e}")

# Información del host local
print(f"\nHostname local: {socket.gethostname()}")
try:
    ip_local = socket.gethostbyname(socket.gethostname())
    print(f"IP local: {ip_local}")
except:
    print("No se pudo resolver IP local")

# Obtener FQDN
print(f"FQDN: {socket.getfqdn()}")

# ========================================
# INFORMACIÓN DE SERVICIOS
# ========================================

print("\n=== INFORMACIÓN DE SERVICIOS ===\n")

# Puerto a nombre de servicio
servicios = [22, 80, 443, 21, 25, 3306]
for puerto in servicios:
    try:
        nombre = socket.getservbyport(puerto, 'tcp')
        print(f"Puerto {puerto} -> {nombre}")
    except:
        print(f"Puerto {puerto} -> desconocido")

# Nombre de servicio a puerto
print()
for servicio in ['ssh', 'http', 'https', 'ftp']:
    try:
        puerto = socket.getservbyname(servicio, 'tcp')
        print(f"{servicio} -> Puerto {puerto}")
    except:
        print(f"{servicio} -> desconocido")</code></pre>

        <h2>1.3 Sockets TCP: Cliente y Servidor</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Sockets TCP: Operaciones fundamentales
"""

import socket

# ========================================
# MÉTODOS PRINCIPALES TCP
# ========================================

"""
SERVIDOR TCP:
1. socket()    - Crear socket
2. bind()      - Asociar a IP:Puerto
3. listen()    - Escuchar conexiones
4. accept()    - Aceptar conexión entrante
5. recv/send   - Recibir/Enviar datos
6. close()     - Cerrar conexión

CLIENTE TCP:
1. socket()    - Crear socket
2. connect()   - Conectar al servidor
3. send/recv   - Enviar/Recibir datos
4. close()     - Cerrar conexión
"""

# ========================================
# SERVIDOR TCP BÁSICO
# ========================================

def servidor_tcp_simple(host='127.0.0.1', puerto=9999):
    """
    Servidor TCP básico que acepta una conexión.
    """
    # Crear socket TCP
    servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # Permitir reutilizar la dirección
    servidor.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        # Asociar a dirección y puerto
        servidor.bind((host, puerto))
        print(f"[*] Servidor enlazado a {host}:{puerto}")
        
        # Escuchar conexiones (backlog=5: cola de conexiones pendientes)
        servidor.listen(5)
        print(f"[*] Escuchando conexiones...")
        
        # Aceptar conexión (bloqueante)
        # Retorna: (socket_cliente, (ip_cliente, puerto_cliente))
        cliente_socket, direccion = servidor.accept()
        print(f"[+] Conexión recibida de {direccion[0]}:{direccion[1]}")
        
        # Recibir datos (máximo 1024 bytes)
        datos = cliente_socket.recv(1024)
        print(f"[+] Datos recibidos: {datos.decode('utf-8')}")
        
        # Enviar respuesta
        respuesta = "Mensaje recibido correctamente"
        cliente_socket.send(respuesta.encode('utf-8'))
        print(f"[+] Respuesta enviada")
        
        # Cerrar conexión del cliente
        cliente_socket.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        servidor.close()
        print("[*] Servidor cerrado")


# ========================================
# CLIENTE TCP BÁSICO
# ========================================

def cliente_tcp_simple(host='127.0.0.1', puerto=9999, mensaje="Hola servidor"):
    """
    Cliente TCP básico que envía un mensaje.
    """
    # Crear socket TCP
    cliente = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # Configurar timeout
        cliente.settimeout(10)
        
        # Conectar al servidor
        cliente.connect((host, puerto))
        print(f"[+] Conectado a {host}:{puerto}")
        
        # Enviar mensaje
        cliente.send(mensaje.encode('utf-8'))
        print(f"[+] Mensaje enviado: {mensaje}")
        
        # Recibir respuesta
        respuesta = cliente.recv(1024)
        print(f"[+] Respuesta: {respuesta.decode('utf-8')}")
        
    except socket.timeout:
        print("[-] Timeout de conexión")
    except socket.error as e:
        print(f"[-] Error de socket: {e}")
    finally:
        cliente.close()
        print("[*] Conexión cerrada")


# ========================================
# SERVIDOR TCP CON MÚLTIPLES MENSAJES
# ========================================

def servidor_tcp_interactivo(host='127.0.0.1', puerto=9999):
    """
    Servidor que mantiene conexión para múltiples mensajes.
    """
    servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    servidor.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        servidor.bind((host, puerto))
        servidor.listen(5)
        print(f"[*] Servidor escuchando en {host}:{puerto}")
        
        cliente_socket, direccion = servidor.accept()
        print(f"[+] Cliente conectado: {direccion}")
        
        # Enviar banner
        cliente_socket.send(b"=== Bienvenido al servidor ===\n")
        
        while True:
            datos = cliente_socket.recv(1024)
            
            if not datos:
                print("[-] Cliente desconectado")
                break
            
            mensaje = datos.decode('utf-8').strip()
            print(f"[CLIENTE] {mensaje}")
            
            if mensaje.lower() == 'exit':
                cliente_socket.send(b"Adios!\n")
                break
            
            # Echo: responder con el mismo mensaje
            respuesta = f"Echo: {mensaje}\n"
            cliente_socket.send(respuesta.encode('utf-8'))
        
        cliente_socket.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        servidor.close()


# ========================================
# EJEMPLO DE USO
# ========================================

if __name__ == "__main__":
    print("=== SOCKETS TCP ===\n")
    print("Para probar, ejecuta en terminales separadas:")
    print("  Terminal 1 (servidor): python script.py servidor")
    print("  Terminal 2 (cliente):  python script.py cliente")
    print("\nO usa netcat:")
    print("  nc localhost 9999")
    
    import sys
    if len(sys.argv) > 1:
        if sys.argv[1] == "servidor":
            servidor_tcp_interactivo()
        elif sys.argv[1] == "cliente":
            cliente_tcp_simple(mensaje="Hola desde el cliente!")</code></pre>

        <h2>1.4 Sockets UDP</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Sockets UDP: comunicación sin conexión
"""

import socket

# ========================================
# UDP vs TCP
# ========================================

"""
UDP NO tiene:
- Conexión establecida (no connect obligatorio)
- Garantía de entrega
- Orden de paquetes
- Control de flujo

UDP usa:
- sendto(datos, (ip, puerto))  - Enviar
- recvfrom(tamaño)             - Recibir (retorna datos y dirección)

Casos de uso:
- DNS (consultas rápidas)
- Streaming de video/audio
- Juegos online
- SNMP, TFTP, DHCP
"""

# ========================================
# SERVIDOR UDP
# ========================================

def servidor_udp(host='127.0.0.1', puerto=9999):
    """Servidor UDP simple."""
    servidor = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    try:
        servidor.bind((host, puerto))
        print(f"[*] Servidor UDP escuchando en {host}:{puerto}")
        
        while True:
            # Recibir datos y dirección del cliente
            datos, direccion = servidor.recvfrom(1024)
            mensaje = datos.decode('utf-8')
            print(f"[{direccion[0]}:{direccion[1]}] {mensaje}")
            
            if mensaje.strip().lower() == 'exit':
                break
            
            # Responder al cliente
            respuesta = f"Recibido: {mensaje}"
            servidor.sendto(respuesta.encode('utf-8'), direccion)
    
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        servidor.close()
        print("[*] Servidor cerrado")


# ========================================
# CLIENTE UDP
# ========================================

def cliente_udp(host='127.0.0.1', puerto=9999, mensaje="Hola UDP"):
    """Cliente UDP simple."""
    cliente = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    try:
        cliente.settimeout(5)
        
        # Enviar mensaje (no requiere connect previo)
        cliente.sendto(mensaje.encode('utf-8'), (host, puerto))
        print(f"[+] Mensaje enviado a {host}:{puerto}")
        
        # Recibir respuesta
        datos, servidor = cliente.recvfrom(1024)
        print(f"[+] Respuesta de {servidor}: {datos.decode('utf-8')}")
        
    except socket.timeout:
        print("[-] Timeout esperando respuesta")
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        cliente.close()


# ========================================
# EJEMPLO: CONSULTA DNS SIMPLE
# ========================================

def consulta_dns_raw(dominio, servidor_dns='8.8.8.8'):
    """
    Ejemplo simplificado de consulta DNS sobre UDP.
    (En producción usar dnspython o resolver del sistema)
    """
    import struct
    import random
    
    # Construir consulta DNS básica
    transaction_id = random.randint(0, 65535)
    
    # Header DNS
    flags = 0x0100  # Recursión deseada
    questions = 1
    header = struct.pack('>HHHHHH', 
                        transaction_id, flags, questions, 0, 0, 0)
    
    # Question section
    question = b''
    for parte in dominio.split('.'):
        question += bytes([len(parte)]) + parte.encode()
    question += b'\x00'  # Fin del nombre
    question += struct.pack('>HH', 1, 1)  # Type A, Class IN
    
    consulta = header + question
    
    # Enviar consulta UDP
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(5)
    
    try:
        sock.sendto(consulta, (servidor_dns, 53))
        respuesta, _ = sock.recvfrom(512)
        
        # Parsear respuesta (simplificado)
        if len(respuesta) > 12:
            answers = struct.unpack('>H', respuesta[6:8])[0]
            print(f"[+] Consulta DNS para {dominio}")
            print(f"    Servidor: {servidor_dns}")
            print(f"    Respuestas: {answers}")
            print(f"    Tamaño respuesta: {len(respuesta)} bytes")
        
    except socket.timeout:
        print("[-] Timeout en consulta DNS")
    finally:
        sock.close()


if __name__ == "__main__":
    print("=== SOCKETS UDP ===\n")
    
    # Demostrar consulta DNS
    consulta_dns_raw("google.com")</code></pre>

        <h2>1.5 Práctica: Chat Cliente-Servidor TCP</h2>

        <p>Esta práctica implementa un sistema de chat completo con servidor multicliente y comandos integrados.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Práctica: Chat simple Cliente-Servidor TCP
"""

import socket
import threading
import sys
from datetime import datetime

# ========================================
# SERVIDOR DE CHAT
# ========================================

class ServidorChat:
    """Servidor de chat TCP que maneja múltiples clientes."""
    
    def __init__(self, host='0.0.0.0', puerto=5555):
        self.host = host
        self.puerto = puerto
        self.servidor = None
        self.clientes = {}  # {socket: nombre}
        self.activo = True
    
    def log(self, mensaje):
        """Imprime mensaje con timestamp."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] {mensaje}")
    
    def broadcast(self, mensaje, excluir=None):
        """Envía mensaje a todos los clientes."""
        for cliente in list(self.clientes.keys()):
            if cliente != excluir:
                try:
                    cliente.send(mensaje.encode('utf-8'))
                except:
                    self.desconectar_cliente(cliente)
    
    def desconectar_cliente(self, cliente):
        """Desconecta un cliente."""
        if cliente in self.clientes:
            nombre = self.clientes[cliente]
            del self.clientes[cliente]
            try:
                cliente.close()
            except:
                pass
            self.log(f"{nombre} se ha desconectado")
            self.broadcast(f"[SERVIDOR] {nombre} ha abandonado el chat")
    
    def manejar_cliente(self, cliente, direccion):
        """Maneja la comunicación con un cliente."""
        try:
            # Solicitar nombre
            cliente.send("Ingresa tu nombre: ".encode('utf-8'))
            nombre = cliente.recv(1024).decode('utf-8').strip()
            
            if not nombre:
                nombre = f"Usuario_{direccion[1]}"
            
            self.clientes[cliente] = nombre
            self.log(f"{nombre} conectado desde {direccion[0]}:{direccion[1]}")
            
            # Anunciar nuevo usuario
            cliente.send(f"¡Bienvenido al chat, {nombre}!\n".encode('utf-8'))
            self.broadcast(f"[SERVIDOR] {nombre} se ha unido al chat", excluir=cliente)
            
            # Bucle de mensajes
            while self.activo:
                try:
                    mensaje = cliente.recv(1024).decode('utf-8').strip()
                    
                    if not mensaje:
                        break
                    
                    if mensaje.lower() == '/salir':
                        break
                    elif mensaje.lower() == '/usuarios':
                        lista = ", ".join(self.clientes.values())
                        cliente.send(f"[SERVIDOR] Usuarios conectados: {lista}\n".encode('utf-8'))
                    elif mensaje.lower() == '/ayuda':
                        ayuda = """
Comandos disponibles:
  /usuarios - Lista usuarios conectados
  /salir    - Salir del chat
  /ayuda    - Mostrar esta ayuda
"""
                        cliente.send(ayuda.encode('utf-8'))
                    else:
                        self.log(f"{nombre}: {mensaje}")
                        self.broadcast(f"{nombre}: {mensaje}", excluir=cliente)
                
                except socket.timeout:
                    continue
                except:
                    break
        
        except Exception as e:
            self.log(f"Error con cliente: {e}")
        
        finally:
            self.desconectar_cliente(cliente)
    
    def iniciar(self):
        """Inicia el servidor de chat."""
        self.servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.servidor.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        try:
            self.servidor.bind((self.host, self.puerto))
            self.servidor.listen(10)
            self.log(f"Servidor de chat iniciado en {self.host}:{self.puerto}")
            
            while self.activo:
                try:
                    self.servidor.settimeout(1.0)
                    cliente, direccion = self.servidor.accept()
                    cliente.settimeout(60)
                    
                    # Crear hilo para el cliente
                    hilo = threading.Thread(
                        target=self.manejar_cliente,
                        args=(cliente, direccion),
                        daemon=True
                    )
                    hilo.start()
                
                except socket.timeout:
                    continue
                except Exception as e:
                    if self.activo:
                        self.log(f"Error aceptando conexión: {e}")
        
        except Exception as e:
            self.log(f"Error del servidor: {e}")
        finally:
            self.detener()
    
    def detener(self):
        """Detiene el servidor."""
        self.activo = False
        self.broadcast("[SERVIDOR] El servidor se está cerrando...")
        
        for cliente in list(self.clientes.keys()):
            try:
                cliente.close()
            except:
                pass
        
        if self.servidor:
            self.servidor.close()
        
        self.log("Servidor detenido")


# ========================================
# CLIENTE DE CHAT
# ========================================

class ClienteChat:
    """Cliente de chat TCP."""
    
    def __init__(self, host='127.0.0.1', puerto=5555):
        self.host = host
        self.puerto = puerto
        self.socket = None
        self.activo = True
    
    def recibir_mensajes(self):
        """Hilo para recibir mensajes del servidor."""
        while self.activo:
            try:
                mensaje = self.socket.recv(1024).decode('utf-8')
                if mensaje:
                    print(f"\r{mensaje}", end="")
                    print("> ", end="", flush=True)
                else:
                    self.activo = False
                    break
            except socket.timeout:
                continue
            except:
                self.activo = False
                break
    
    def conectar(self):
        """Conecta al servidor de chat."""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        try:
            self.socket.connect((self.host, self.puerto))
            self.socket.settimeout(1.0)
            print(f"[+] Conectado a {self.host}:{self.puerto}")
            
            # Iniciar hilo para recibir mensajes
            hilo_recibir = threading.Thread(target=self.recibir_mensajes, daemon=True)
            hilo_recibir.start()
            
            # Bucle para enviar mensajes
            while self.activo:
                try:
                    mensaje = input("> ")
                    if mensaje:
                        self.socket.send(mensaje.encode('utf-8'))
                        if mensaje.lower() == '/salir':
                            break
                except EOFError:
                    break
                except KeyboardInterrupt:
                    break
        
        except ConnectionRefusedError:
            print(f"[-] No se pudo conectar a {self.host}:{self.puerto}")
        except Exception as e:
            print(f"[-] Error: {e}")
        finally:
            self.activo = False
            if self.socket:
                self.socket.close()
            print("\n[*] Desconectado")


# ========================================
# MAIN
# ========================================

def mostrar_uso():
    """Muestra instrucciones de uso."""
    print("""
=== CHAT TCP ===

Uso:
  python chat.py servidor [puerto]    - Iniciar servidor
  python chat.py cliente [host] [puerto]  - Conectar como cliente

Ejemplos:
  python chat.py servidor 5555
  python chat.py cliente 127.0.0.1 5555

Comandos del chat:
  /usuarios - Lista usuarios conectados
  /salir    - Salir del chat
  /ayuda    - Mostrar ayuda
""")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        mostrar_uso()
        sys.exit(1)
    
    modo = sys.argv[1].lower()
    
    if modo == "servidor":
        puerto = int(sys.argv[2]) if len(sys.argv) > 2 else 5555
        servidor = ServidorChat(puerto=puerto)
        try:
            servidor.iniciar()
        except KeyboardInterrupt:
            print("\n[*] Cerrando servidor...")
            servidor.detener()
    
    elif modo == "cliente":
        host = sys.argv[2] if len(sys.argv) > 2 else "127.0.0.1"
        puerto = int(sys.argv[3]) if len(sys.argv) > 3 else 5555
        cliente = ClienteChat(host=host, puerto=puerto)
        cliente.conectar()
    
    else:
        mostrar_uso()</code></pre>

        <h1>BLOQUE 2: Aplicaciones de Red</h1>

        <h2>2.1 Escáner de Puertos TCP Básico</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Escáner de puertos TCP básico
"""

import socket
import sys
from datetime import datetime

# ========================================
# ESCANEO DE PUERTO INDIVIDUAL
# ========================================

def escanear_puerto(host, puerto, timeout=1):
    """
    Escanea un puerto individual.
    
    Returns:
        tuple: (puerto, estado, banner)
        estado: 'open', 'closed', 'filtered'
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        
        # Intentar conexión
        resultado = sock.connect_ex((host, puerto))
        
        if resultado == 0:
            # Puerto abierto - intentar obtener banner
            banner = obtener_banner(sock, puerto)
            sock.close()
            return (puerto, 'open', banner)
        else:
            sock.close()
            return (puerto, 'closed', None)
    
    except socket.timeout:
        return (puerto, 'filtered', None)
    except socket.error as e:
        return (puerto, 'error', str(e))
    except Exception as e:
        return (puerto, 'error', str(e))


def obtener_banner(sock, puerto):
    """Intenta obtener el banner de un servicio."""
    try:
        # Algunos servicios envían banner al conectar
        sock.settimeout(2)
        
        # Para HTTP, necesitamos enviar una petición
        if puerto in [80, 8080, 8000, 8888]:
            sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
        elif puerto == 443:
            return "HTTPS (SSL/TLS)"
        
        banner = sock.recv(1024)
        return banner.decode('utf-8', errors='ignore').strip()[:100]
    
    except:
        return None


# ========================================
# ESCÁNER SIMPLE
# ========================================

def escanear_puertos_simple(host, puertos, timeout=1):
    """
    Escanea una lista de puertos de forma secuencial.
    """
    print(f"\n{'='*60}")
    print(f"  ESCÁNER DE PUERTOS - {host}")
    print(f"  Inicio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*60}\n")
    
    # Resolver hostname
    try:
        ip = socket.gethostbyname(host)
        if ip != host:
            print(f"[*] Host: {host} ({ip})")
        else:
            print(f"[*] Host: {host}")
    except socket.gaierror:
        print(f"[-] No se pudo resolver: {host}")
        return []
    
    print(f"[*] Puertos a escanear: {len(puertos)}")
    print(f"[*] Timeout: {timeout}s\n")
    
    puertos_abiertos = []
    
    for i, puerto in enumerate(puertos, 1):
        puerto_num, estado, banner = escanear_puerto(ip, puerto, timeout)
        
        # Mostrar progreso
        progreso = f"[{i}/{len(puertos)}]"
        
        if estado == 'open':
            puertos_abiertos.append((puerto_num, banner))
            servicio = socket.getservbyport(puerto_num, 'tcp') if puerto_num < 1024 else 'unknown'
            print(f"{progreso} Puerto {puerto_num}/tcp ABIERTO ({servicio})")
            if banner:
                print(f"        └─ Banner: {banner[:60]}")
    
    # Resumen
    print(f"\n{'='*60}")
    print(f"  RESUMEN: {len(puertos_abiertos)} puertos abiertos de {len(puertos)} escaneados")
    print(f"  Fin: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*60}\n")
    
    return puertos_abiertos


# ========================================
# PUERTOS COMUNES
# ========================================

PUERTOS_TOP_100 = [
    7, 20, 21, 22, 23, 25, 53, 69, 80, 88,
    110, 111, 119, 123, 135, 137, 138, 139, 143, 161,
    162, 179, 194, 389, 443, 445, 464, 465, 514, 515,
    587, 593, 636, 691, 993, 995, 1025, 1026, 1027, 1028,
    1029, 1110, 1433, 1434, 1521, 1720, 1723, 1755, 1900, 2000,
    2001, 2049, 2121, 2717, 3000, 3128, 3306, 3389, 3986, 4899,
    5000, 5009, 5051, 5060, 5101, 5190, 5357, 5432, 5631, 5666,
    5800, 5900, 6000, 6001, 6646, 7070, 8000, 8008, 8080, 8443,
    8888, 9100, 9999, 10000, 32768, 49152, 49153, 49154, 49155, 49156
]

PUERTOS_CRITICOS = [
    21,    # FTP
    22,    # SSH
    23,    # Telnet
    25,    # SMTP
    53,    # DNS
    80,    # HTTP
    110,   # POP3
    135,   # MSRPC
    139,   # NetBIOS
    143,   # IMAP
    443,   # HTTPS
    445,   # SMB
    993,   # IMAPS
    995,   # POP3S
    1433,  # MSSQL
    1521,  # Oracle
    3306,  # MySQL
    3389,  # RDP
    5432,  # PostgreSQL
    5900,  # VNC
    6379,  # Redis
    8080,  # HTTP Alt
    27017, # MongoDB
]


# ========================================
# MAIN
# ========================================

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Uso: python escaner.py <host> [puerto_inicio] [puerto_fin]")
        print("     python escaner.py <host> --top100")
        print("     python escaner.py <host> --criticos")
        print("\nEjemplos:")
        print("  python escaner.py 192.168.1.1")
        print("  python escaner.py scanme.nmap.org 1 1000")
        print("  python escaner.py 10.0.0.1 --top100")
        sys.exit(1)
    
    host = sys.argv[1]
    
    if len(sys.argv) == 2:
        puertos = PUERTOS_CRITICOS
    elif sys.argv[2] == "--top100":
        puertos = PUERTOS_TOP_100
    elif sys.argv[2] == "--criticos":
        puertos = PUERTOS_CRITICOS
    else:
        inicio = int(sys.argv[2])
        fin = int(sys.argv[3]) if len(sys.argv) > 3 else inicio
        puertos = range(inicio, fin + 1)
    
    try:
        escanear_puertos_simple(host, puertos)
    except KeyboardInterrupt:
        print("\n[!] Escaneo cancelado por el usuario")</code></pre>

        <h2>2.2 Banner Grabbing</h2>

        <p>El <strong>banner grabbing</strong> es una técnica para obtener información de servicios de red mediante la captura de banners que los servicios envían al establecer conexión.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Banner Grabbing: obtención de información de servicios
"""

import socket
import ssl

# ========================================
# TÉCNICAS DE BANNER GRABBING
# ========================================

def grab_banner_tcp(host, puerto, timeout=5):
    """
    Obtiene el banner de un servicio TCP.
    Algunos servicios envían banner al conectar.
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, puerto))
        
        # Esperar banner automático
        sock.settimeout(3)
        try:
            banner = sock.recv(1024)
            if banner:
                sock.close()
                return banner.decode('utf-8', errors='ignore').strip()
        except socket.timeout:
            pass
        
        sock.close()
        return None
    
    except Exception as e:
        return f"Error: {e}"


def grab_banner_http(host, puerto=80, timeout=5):
    """Obtiene información de un servidor HTTP."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, puerto))
        
        # Enviar petición HTTP
        request = f"HEAD / HTTP/1.1\r\nHost: {host}\r\nConnection: close\r\n\r\n"
        sock.send(request.encode())
        
        response = sock.recv(4096).decode('utf-8', errors='ignore')
        sock.close()
        
        # Parsear headers
        info = {
            'raw': response[:500],
            'server': None,
            'powered_by': None,
            'status': None
        }
        
        for linea in response.split('\r\n'):
            linea_lower = linea.lower()
            if linea.startswith('HTTP/'):
                info['status'] = linea
            elif linea_lower.startswith('server:'):
                info['server'] = linea.split(':', 1)[1].strip()
            elif linea_lower.startswith('x-powered-by:'):
                info['powered_by'] = linea.split(':', 1)[1].strip()
        
        return info
    
    except Exception as e:
        return {'error': str(e)}


def grab_banner_https(host, puerto=443, timeout=5):
    """Obtiene información de un servidor HTTPS incluyendo certificado."""
    try:
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        
        ssl_sock = context.wrap_socket(sock, server_hostname=host)
        ssl_sock.connect((host, puerto))
        
        # Información del certificado
        cert = ssl_sock.getpeercert(binary_form=False)
        
        info = {
            'ssl_version': ssl_sock.version(),
            'cipher': ssl_sock.cipher(),
        }
        
        if cert:
            info['subject'] = dict(x[0] for x in cert.get('subject', []))
            info['issuer'] = dict(x[0] for x in cert.get('issuer', []))
            info['notBefore'] = cert.get('notBefore')
            info['notAfter'] = cert.get('notAfter')
        
        # También obtener banner HTTP
        request = f"HEAD / HTTP/1.1\r\nHost: {host}\r\nConnection: close\r\n\r\n"
        ssl_sock.send(request.encode())
        response = ssl_sock.recv(4096).decode('utf-8', errors='ignore')
        
        for linea in response.split('\r\n'):
            if linea.lower().startswith('server:'):
                info['server'] = linea.split(':', 1)[1].strip()
        
        ssl_sock.close()
        return info
    
    except Exception as e:
        return {'error': str(e)}


def grab_banner_ftp(host, puerto=21, timeout=5):
    """Obtiene banner de servidor FTP."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, puerto))
        
        banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
        sock.close()
        
        return {'banner': banner, 'puerto': puerto}
    
    except Exception as e:
        return {'error': str(e)}


def grab_banner_ssh(host, puerto=22, timeout=5):
    """Obtiene banner de servidor SSH."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, puerto))
        
        banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
        sock.close()
        
        # Parsear versión SSH
        info = {'banner': banner}
        if banner.startswith('SSH-'):
            partes = banner.split('-')
            if len(partes) >= 3:
                info['version_protocolo'] = partes[1]
                info['software'] = '-'.join(partes[2:])
        
        return info
    
    except Exception as e:
        return {'error': str(e)}


def grab_banner_smtp(host, puerto=25, timeout=5):
    """Obtiene banner de servidor SMTP."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, puerto))
        
        banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
        
        # Enviar EHLO para más información
        sock.send(b"EHLO test\r\n")
        ehlo_response = sock.recv(2048).decode('utf-8', errors='ignore')
        
        sock.send(b"QUIT\r\n")
        sock.close()
        
        return {
            'banner': banner,
            'ehlo_response': ehlo_response.strip()
        }
    
    except Exception as e:
        return {'error': str(e)}


# ========================================
# GRABBER UNIVERSAL
# ========================================

def banner_grabber(host, puerto, timeout=5):
    """
    Determina el tipo de servicio e intenta obtener el banner.
    """
    # Servicios conocidos por puerto
    grabbers = {
        21: ('FTP', grab_banner_ftp),
        22: ('SSH', grab_banner_ssh),
        25: ('SMTP', grab_banner_smtp),
        80: ('HTTP', grab_banner_http),
        443: ('HTTPS', grab_banner_https),
        8080: ('HTTP', grab_banner_http),
        8443: ('HTTPS', grab_banner_https),
    }
    
    if puerto in grabbers:
        nombre, funcion = grabbers[puerto]
        resultado = funcion(host, puerto, timeout)
        resultado['servicio_detectado'] = nombre
        return resultado
    
    # Para otros puertos, intentar banner genérico
    banner = grab_banner_tcp(host, puerto, timeout)
    return {
        'servicio_detectado': 'Desconocido',
        'banner': banner
    }


# ========================================
# DEMOSTRACIÓN
# ========================================

def demo_banner_grabbing(host):
    """Demostración de banner grabbing en puertos comunes."""
    print(f"\n{'='*60}")
    print(f"  BANNER GRABBING - {host}")
    print(f"{'='*60}\n")
    
    puertos_prueba = [21, 22, 25, 80, 443, 8080]
    
    for puerto in puertos_prueba:
        print(f"[*] Probando puerto {puerto}...")
        resultado = banner_grabber(host, puerto, timeout=3)
        
        if 'error' in resultado:
            print(f"    [-] Error: {resultado['error'][:50]}")
        else:
            print(f"    [+] Servicio: {resultado.get('servicio_detectado', 'N/A')}")
            if 'banner' in resultado and resultado['banner']:
                banner_limpio = resultado['banner'][:80].replace('\n', ' ')
                print(f"    [+] Banner: {banner_limpio}")
            if 'server' in resultado:
                print(f"    [+] Server: {resultado['server']}")
            if 'ssl_version' in resultado:
                print(f"    [+] SSL: {resultado['ssl_version']}")
        print()


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Uso: python banner_grabber.py <host> [puerto]")
        sys.exit(1)
    
    host = sys.argv[1]
    
    if len(sys.argv) > 2:
        puerto = int(sys.argv[2])
        resultado = banner_grabber(host, puerto)
        print(f"\nResultado para {host}:{puerto}")
        for clave, valor in resultado.items():
            print(f"  {clave}: {valor}")
    else:
        demo_banner_grabbing(host)</code></pre>

        <h2>2.3 Escáner de Puertos Multihilo</h2>

        <p>El uso de <strong>multithreading</strong> permite escanear múltiples puertos simultáneamente, mejorando significativamente la velocidad del escaneo.</p>

        <blockquote>
            <strong>Nota:</strong> El multithreading es especialmente útil en operaciones de I/O como el escaneo de puertos, donde el tiempo de espera es el factor limitante principal.
        </blockquote>

        <details>
            <summary>¿Cuál es la diferencia entre threading.Thread y ThreadPoolExecutor?</summary>
            <p><code>threading.Thread</code> requiere gestión manual de hilos, mientras que <code>ThreadPoolExecutor</code> proporciona una interfaz de alto nivel que gestiona automáticamente un pool de workers, facilitando el manejo de múltiples tareas concurrentes.</p>
        </details>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Escáner de puertos TCP con multithreading
"""

import socket
import threading
import queue
import sys
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

# ========================================
# ESCÁNER CON THREADING BÁSICO
# ========================================

class EscanerPuertosThreading:
    """Escáner de puertos usando threading y queue."""
    
    def __init__(self, host, timeout=1, hilos=100):
        self.host = host
        self.timeout = timeout
        self.num_hilos = hilos
        self.cola_puertos = queue.Queue()
        self.resultados = []
        self.lock = threading.Lock()
        self.puertos_escaneados = 0
        self.total_puertos = 0
    
    def escanear_puerto(self, puerto):
        """Escanea un puerto individual."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            resultado = sock.connect_ex((self.host, puerto))
            sock.close()
            return resultado == 0
        except:
            return False
    
    def worker(self):
        """Hilo trabajador que procesa puertos de la cola."""
        while True:
            try:
                puerto = self.cola_puertos.get(timeout=1)
            except queue.Empty:
                break
            
            if self.escanear_puerto(puerto):
                with self.lock:
                    self.resultados.append(puerto)
            
            with self.lock:
                self.puertos_escaneados += 1
            
            self.cola_puertos.task_done()
    
    def escanear(self, puertos):
        """Ejecuta el escaneo de puertos."""
        self.total_puertos = len(puertos)
        
        # Llenar la cola con puertos
        for puerto in puertos:
            self.cola_puertos.put(puerto)
        
        # Crear y ejecutar hilos
        hilos = []
        for _ in range(min(self.num_hilos, self.total_puertos)):
            t = threading.Thread(target=self.worker, daemon=True)
            t.start()
            hilos.append(t)
        
        # Esperar a que termine
        self.cola_puertos.join()
        
        return sorted(self.resultados)


# ========================================
# ESCÁNER CON ThreadPoolExecutor
# ========================================

class EscanerPuertosPool:
    """Escáner usando ThreadPoolExecutor (más moderno)."""
    
    def __init__(self, host, timeout=1, max_workers=100):
        self.host = host
        self.timeout = timeout
        self.max_workers = max_workers
    
    def escanear_puerto(self, puerto):
        """Escanea un puerto y retorna resultado."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            resultado = sock.connect_ex((self.host, puerto))
            
            banner = None
            if resultado == 0:
                try:
                    sock.settimeout(2)
                    banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()[:100]
                except:
                    pass
            
            sock.close()
            
            return {
                'puerto': puerto,
                'abierto': resultado == 0,
                'banner': banner
            }
        except Exception as e:
            return {
                'puerto': puerto,
                'abierto': False,
                'error': str(e)
            }
    
    def escanear(self, puertos, callback_progreso=None):
        """Ejecuta el escaneo con ThreadPoolExecutor."""
        resultados = []
        total = len(puertos)
        completados = 0
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # Enviar todas las tareas
            futures = {executor.submit(self.escanear_puerto, p): p for p in puertos}
            
            # Procesar resultados a medida que completan
            for future in as_completed(futures):
                resultado = future.result()
                completados += 1
                
                if resultado['abierto']:
                    resultados.append(resultado)
                
                if callback_progreso:
                    callback_progreso(completados, total, resultado)
        
        return sorted(resultados, key=lambda x: x['puerto'])


# ========================================
# ESCÁNER COMPLETO
# ========================================

def escanear_con_progreso(host, puertos, timeout=1, hilos=100):
    """Escaneo con barra de progreso."""
    print(f"\n{'='*60}")
    print(f"  ESCÁNER DE PUERTOS MULTIHILO")
    print(f"{'='*60}")
    
    # Resolver host
    try:
        ip = socket.gethostbyname(host)
        print(f"\n[*] Objetivo: {host} ({ip})")
    except socket.gaierror:
        print(f"[-] No se pudo resolver: {host}")
        return []
    
    print(f"[*] Puertos: {min(puertos)}-{max(puertos)} ({len(puertos)} total)")
    print(f"[*] Hilos: {hilos}")
    print(f"[*] Timeout: {timeout}s")
    
    inicio = datetime.now()
    print(f"[*] Inicio: {inicio.strftime('%H:%M:%S')}\n")
    
    # Variables para progreso
    puertos_abiertos = []
    ultimo_porcentaje = 0
    
    def mostrar_progreso(completados, total, resultado):
        nonlocal ultimo_porcentaje, puertos_abiertos
        
        porcentaje = int(completados * 100 / total)
        
        if resultado['abierto']:
            puerto = resultado['puerto']
            try:
                servicio = socket.getservbyport(puerto, 'tcp')
            except:
                servicio = 'unknown'
            
            puertos_abiertos.append(resultado)
            print(f"\r[+] Puerto {puerto}/tcp ABIERTO ({servicio})           ")
        
        # Mostrar progreso cada 5%
        if porcentaje >= ultimo_porcentaje + 5:
            barra = '#' * (porcentaje // 5) + '-' * (20 - porcentaje // 5)
            print(f"\r[{barra}] {porcentaje}% ({completados}/{total})    ", end='', flush=True)
            ultimo_porcentaje = porcentaje
    
    # Ejecutar escaneo
    escaner = EscanerPuertosPool(ip, timeout=timeout, max_workers=hilos)
    resultados = escaner.escanear(puertos, callback_progreso=mostrar_progreso)
    
    fin = datetime.now()
    duracion = (fin - inicio).total_seconds()
    
    # Resumen
    print(f"\n\n{'='*60}")
    print(f"  RESULTADOS")
    print(f"{'='*60}")
    
    if resultados:
        print(f"\n[+] Puertos abiertos: {len(resultados)}\n")
        print(f"{'PUERTO':<10} {'ESTADO':<10} {'SERVICIO':<15} {'BANNER'}")
        print("-" * 60)
        
        for r in resultados:
            puerto = r['puerto']
            try:
                servicio = socket.getservbyport(puerto, 'tcp')
            except:
                servicio = 'unknown'
            
            banner = r.get('banner', '')[:30] if r.get('banner') else ''
            print(f"{puerto:<10} {'open':<10} {servicio:<15} {banner}")
    else:
        print("\n[-] No se encontraron puertos abiertos")
    
    print(f"\n[*] Duración: {duracion:.2f} segundos")
    print(f"[*] Velocidad: {len(puertos)/duracion:.0f} puertos/segundo")
    print(f"{'='*60}\n")
    
    return resultados


# ========================================
# ESCANEOS PREDEFINIDOS
# ========================================

ESCANEO_RAPIDO = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 
                  143, 443, 445, 993, 995, 1723, 3306, 3389, 
                  5900, 8080]

ESCANEO_TOP_100 = list(range(1, 101)) + [
    110, 111, 135, 139, 143, 443, 445, 993, 995,
    1433, 1521, 1723, 3306, 3389, 5432, 5900, 6379,
    8000, 8080, 8443, 8888, 9090, 27017
]

ESCANEO_COMPLETO = list(range(1, 1025))  # Puertos privilegiados
ESCANEO_TOTAL = list(range(1, 65536))    # Todos los puertos


# ========================================
# MAIN
# ========================================

if __name__ == "__main__":
    print("""
╔═══════════════════════════════════════════════════════════╗
║          ESCÁNER DE PUERTOS TCP MULTIHILO                 ║
╠═══════════════════════════════════════════════════════════╣
║  Uso: python escaner_multihilo.py <host> [opciones]       ║
║                                                           ║
║  Opciones de rango:                                       ║
║    -p 1-1000      Rango de puertos                        ║
║    --top20        Puertos más comunes (20)                ║
║    --top100       Top 100 puertos                         ║
║    --full         Puertos 1-1024                          ║
║                                                           ║
║  Opciones adicionales:                                    ║
║    -t, --threads  Número de hilos (default: 100)          ║
║    --timeout      Timeout en segundos (default: 1)        ║
╚═══════════════════════════════════════════════════════════╝
""")
    
    if len(sys.argv) < 2:
        print("Ejemplo: python escaner_multihilo.py scanme.nmap.org --top20")
        sys.exit(1)
    
    host = sys.argv[1]
    puertos = ESCANEO_RAPIDO  # Default
    hilos = 100
    timeout = 1
    
    # Parsear argumentos
    i = 2
    while i < len(sys.argv):
        arg = sys.argv[i]
        
        if arg == '-p' and i + 1 < len(sys.argv):
            rango = sys.argv[i + 1]
            if '-' in rango:
                inicio, fin = map(int, rango.split('-'))
                puertos = list(range(inicio, fin + 1))
            else:
                puertos = [int(rango)]
            i += 2
        elif arg == '--top20':
            puertos = ESCANEO_RAPIDO
            i += 1
        elif arg == '--top100':
            puertos = ESCANEO_TOP_100
            i += 1
        elif arg == '--full':
            puertos = ESCANEO_COMPLETO
            i += 1
        elif arg in ['-t', '--threads'] and i + 1 < len(sys.argv):
            hilos = int(sys.argv[i + 1])
            i += 2
        elif arg == '--timeout' and i + 1 < len(sys.argv):
            timeout = float(sys.argv[i + 1])
            i += 2
        else:
            i += 1
    
    try:
        escanear_con_progreso(host, puertos, timeout=timeout, hilos=hilos)
    except KeyboardInterrupt:
        print("\n\n[!] Escaneo cancelado por el usuario")
    except Exception as e:
        print(f"\n[-] Error: {e}")</code></pre>

        <h1>BLOQUE 3: HTTP y Peticiones Web</h1>

        <h2>3.1 Módulo requests: Fundamentos</h2>

        <p>El módulo <code>requests</code> es la biblioteca estándar de facto para realizar peticiones HTTP en Python. Simplifica enormemente el trabajo con APIs y servicios web.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo requests: peticiones HTTP
"""

import requests
from pprint import pprint

# ========================================
# INSTALACIÓN
# ========================================

# pip install requests

# ========================================
# PETICIONES GET
# ========================================

print("=== PETICIONES GET ===\n")

# GET simple
response = requests.get('https://httpbin.org/get')
print(f"Status Code: {response.status_code}")
print(f"URL: {response.url}")
print(f"Encoding: {response.encoding}")

# Contenido de la respuesta
print(f"\nContenido (primeros 200 chars):")
print(response.text[:200])

# Como JSON
datos = response.json()
print(f"\nComo JSON:")
print(f"  Origin: {datos.get('origin')}")
print(f"  Headers recibidos por servidor: {list(datos.get('headers', {}).keys())}")

# GET con parámetros
params = {
    'search': 'python',
    'page': 1,
    'limit': 10
}
response = requests.get('https://httpbin.org/get', params=params)
print(f"\nURL con parámetros: {response.url}")

# ========================================
# PETICIONES POST
# ========================================

print("\n=== PETICIONES POST ===\n")

# POST con datos de formulario
data = {
    'username': 'admin',
    'password': 'secret123'
}
response = requests.post('https://httpbin.org/post', data=data)
resultado = response.json()
print(f"Datos enviados (form): {resultado.get('form')}")

# POST con JSON
json_data = {
    'name': 'Test User',
    'email': 'test@example.com',
    'roles': ['admin', 'user']
}
response = requests.post('https://httpbin.org/post', json=json_data)
resultado = response.json()
print(f"Datos enviados (json): {resultado.get('json')}")

# ========================================
# HEADERS
# ========================================

print("\n=== HEADERS PERSONALIZADOS ===\n")

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Accept': 'application/json',
    'Authorization': 'Bearer token123',
    'X-Custom-Header': 'valor-personalizado'
}

response = requests.get('https://httpbin.org/headers', headers=headers)
resultado = response.json()

print("Headers enviados:")
for header, valor in resultado.get('headers', {}).items():
    print(f"  {header}: {valor[:50]}...")

# Headers de respuesta
print(f"\nHeaders de respuesta:")
for header, valor in list(response.headers.items())[:5]:
    print(f"  {header}: {valor}")

# ========================================
# COOKIES
# ========================================

print("\n=== COOKIES ===\n")

# Enviar cookies
cookies = {
    'session_id': 'abc123',
    'user_pref': 'dark_mode'
}
response = requests.get('https://httpbin.org/cookies', cookies=cookies)
print(f"Cookies enviadas: {response.json()}")

# Recibir cookies (usando session)
session = requests.Session()
response = session.get('https://httpbin.org/cookies/set/test_cookie/test_value')
print(f"Cookies en session: {dict(session.cookies)}")

# ========================================
# AUTENTICACIÓN
# ========================================

print("\n=== AUTENTICACIÓN ===\n")

# Basic Auth
response = requests.get(
    'https://httpbin.org/basic-auth/user/passwd',
    auth=('user', 'passwd')
)
print(f"Basic Auth: {response.status_code} - {response.json()}")

# Bearer Token (ya visto en headers)

# ========================================
# TIMEOUT Y ERRORES
# ========================================

print("\n=== MANEJO DE ERRORES ===\n")

# Timeout
try:
    response = requests.get('https://httpbin.org/delay/10', timeout=2)
except requests.exceptions.Timeout:
    print("[!] Timeout alcanzado")

# Error de conexión
try:
    response = requests.get('http://servidor.inexistente.local', timeout=2)
except requests.exceptions.ConnectionError:
    print("[!] Error de conexión")

# Verificar status code
response = requests.get('https://httpbin.org/status/404')
print(f"Status 404: {response.status_code}")

# Lanzar excepción para status codes de error
try:
    response = requests.get('https://httpbin.org/status/500')
    response.raise_for_status()  # Lanza HTTPError si status >= 400
except requests.exceptions.HTTPError as e:
    print(f"[!] HTTP Error: {e}")

# ========================================
# SESIONES
# ========================================

print("\n=== SESIONES ===\n")

# Las sesiones mantienen cookies, headers, etc.
session = requests.Session()

# Configurar headers para toda la sesión
session.headers.update({
    'User-Agent': 'SecurityScanner/1.0',
    'Accept': 'application/json'
})

# Todas las peticiones usarán estos headers
response1 = session.get('https://httpbin.org/get')
response2 = session.get('https://httpbin.org/headers')

print("Sesión mantiene headers y cookies entre peticiones")

# ========================================
# OTROS MÉTODOS HTTP
# ========================================

print("\n=== OTROS MÉTODOS HTTP ===\n")

# PUT
response = requests.put('https://httpbin.org/put', json={'updated': True})
print(f"PUT: {response.status_code}")

# DELETE
response = requests.delete('https://httpbin.org/delete')
print(f"DELETE: {response.status_code}")

# PATCH
response = requests.patch('https://httpbin.org/patch', json={'partial': 'update'})
print(f"PATCH: {response.status_code}")

# OPTIONS
response = requests.options('https://httpbin.org/get')
print(f"OPTIONS Allow: {response.headers.get('Allow', 'N/A')}")

# HEAD (solo headers, sin body)
response = requests.head('https://httpbin.org/get')
print(f"HEAD: {response.status_code}, Content-Length: {response.headers.get('Content-Length')}")</code></pre>

        <h2>3.2 Análisis de Respuestas HTTP</h2>

        <p>El análisis detallado de respuestas HTTP permite identificar tecnologías, configuraciones de seguridad y posibles vulnerabilidades en aplicaciones web.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Análisis detallado de respuestas HTTP
"""

import requests
from urllib.parse import urlparse
import json

# ========================================
# ANALIZADOR DE RESPUESTAS
# ========================================

class AnalizadorHTTP:
    """Analiza respuestas HTTP en detalle."""
    
    def __init__(self, timeout=10):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def analizar_url(self, url):
        """Analiza una URL y retorna información detallada."""
        resultado = {
            'url': url,
            'accesible': False,
            'status_code': None,
            'headers': {},
            'cookies': {},
            'redirects': [],
            'tecnologias': [],
            'seguridad': {},
            'errores': []
        }
        
        try:
            # Petición con seguimiento de redirects
            response = self.session.get(
                url,
                timeout=self.timeout,
                allow_redirects=True,
                verify=True
            )
            
            resultado['accesible'] = True
            resultado['status_code'] = response.status_code
            resultado['url_final'] = response.url
            resultado['tiempo_respuesta'] = response.elapsed.total_seconds()
            
            # Registrar redirects
            for r in response.history:
                resultado['redirects'].append({
                    'url': r.url,
                    'status': r.status_code
                })
            
            # Headers
            resultado['headers'] = dict(response.headers)
            
            # Cookies
            resultado['cookies'] = dict(response.cookies)
            
            # Analizar headers de seguridad
            resultado['seguridad'] = self._analizar_seguridad(response.headers)
            
            # Detectar tecnologías
            resultado['tecnologias'] = self._detectar_tecnologias(response)
            
        except requests.exceptions.SSLError as e:
            resultado['errores'].append(f"SSL Error: {str(e)[:100]}")
        except requests.exceptions.ConnectionError as e:
            resultado['errores'].append(f"Connection Error: {str(e)[:100]}")
        except requests.exceptions.Timeout:
            resultado['errores'].append("Timeout")
        except Exception as e:
            resultado['errores'].append(f"Error: {str(e)[:100]}")
        
        return resultado
    
    def _analizar_seguridad(self, headers):
        """Analiza headers de seguridad."""
        headers_lower = {k.lower(): v for k, v in headers.items()}
        
        seguridad = {
            'headers_presentes': [],
            'headers_faltantes': [],
            'puntuacion': 0
        }
        
        # Headers de seguridad importantes
        headers_seguridad = {
            'strict-transport-security': 'HSTS - Fuerza HTTPS',
            'content-security-policy': 'CSP - Política de contenido',
            'x-frame-options': 'Previene clickjacking',
            'x-content-type-options': 'Previene MIME sniffing',
            'x-xss-protection': 'Protección XSS (legacy)',
            'referrer-policy': 'Control de Referrer',
            'permissions-policy': 'Política de permisos',
            'x-permitted-cross-domain-policies': 'Políticas cross-domain',
        }
        
        for header, descripcion in headers_seguridad.items():
            if header in headers_lower:
                seguridad['headers_presentes'].append({
                    'nombre': header,
                    'descripcion': descripcion,
                    'valor': headers_lower[header][:100]
                })
                seguridad['puntuacion'] += 1
            else:
                seguridad['headers_faltantes'].append({
                    'nombre': header,
                    'descripcion': descripcion
                })
        
        # Calcular grado
        total = len(headers_seguridad)
        presentes = len(seguridad['headers_presentes'])
        porcentaje = (presentes / total) * 100
        
        if porcentaje >= 80:
            seguridad['grado'] = 'A'
        elif porcentaje >= 60:
            seguridad['grado'] = 'B'
        elif porcentaje >= 40:
            seguridad['grado'] = 'C'
        elif porcentaje >= 20:
            seguridad['grado'] = 'D'
        else:
            seguridad['grado'] = 'F'
        
        seguridad['porcentaje'] = porcentaje
        
        return seguridad
    
    def _detectar_tecnologias(self, response):
        """Detecta tecnologías basándose en headers y contenido."""
        tecnologias = []
        headers = {k.lower(): v for k, v in response.headers.items()}
        
        # Por Server header
        if 'server' in headers:
            server = headers['server']
            tecnologias.append(f"Server: {server}")
        
        # Por X-Powered-By
        if 'x-powered-by' in headers:
            tecnologias.append(f"Powered By: {headers['x-powered-by']}")
        
        # Por otros headers
        if 'x-aspnet-version' in headers:
            tecnologias.append(f"ASP.NET: {headers['x-aspnet-version']}")
        
        if 'x-drupal-cache' in headers:
            tecnologias.append("CMS: Drupal")
        
        # Por contenido (básico)
        content = response.text[:5000].lower()
        
        if 'wp-content' in content or 'wordpress' in content:
            tecnologias.append("CMS: WordPress")
        elif 'joomla' in content:
            tecnologias.append("CMS: Joomla")
        
        if 'jquery' in content:
            tecnologias.append("JS: jQuery")
        if 'bootstrap' in content:
            tecnologias.append("CSS: Bootstrap")
        if 'react' in content:
            tecnologias.append("JS: React")
        if 'vue' in content:
            tecnologias.append("JS: Vue.js")
        
        return tecnologias
    
    def imprimir_analisis(self, resultado):
        """Imprime el análisis de forma legible."""
        print(f"\n{'='*60}")
        print(f"  ANÁLISIS HTTP: {resultado['url']}")
        print(f"{'='*60}\n")
        
        if resultado['accesible']:
            print(f"[+] Estado: {resultado['status_code']}")
            print(f"[+] URL Final: {resultado.get('url_final', 'N/A')}")
            print(f"[+] Tiempo: {resultado.get('tiempo_respuesta', 0):.2f}s")
            
            if resultado['redirects']:
                print(f"\n[*] Redirecciones:")
                for r in resultado['redirects']:
                    print(f"    {r['status']} -> {r['url']}")
            
            if resultado['tecnologias']:
                print(f"\n[*] Tecnologías detectadas:")
                for tech in resultado['tecnologias']:
                    print(f"    - {tech}")
            
            # Seguridad
            seg = resultado['seguridad']
            print(f"\n[*] Seguridad: Grado {seg['grado']} ({seg['porcentaje']:.0f}%)")
            
            if seg['headers_presentes']:
                print(f"\n    ✓ Headers presentes:")
                for h in seg['headers_presentes']:
                    print(f"      - {h['nombre']}")
            
            if seg['headers_faltantes']:
                print(f"\n    ✗ Headers faltantes:")
                for h in seg['headers_faltantes'][:5]:
                    print(f"      - {h['nombre']}: {h['descripcion']}")
            
            # Cookies
            if resultado['cookies']:
                print(f"\n[*] Cookies ({len(resultado['cookies'])}):")
                for nombre, valor in list(resultado['cookies'].items())[:5]:
                    print(f"    - {nombre}: {valor[:30]}...")
        else:
            print(f"[-] No accesible")
            for error in resultado['errores']:
                print(f"    Error: {error}")
        
        print(f"\n{'='*60}")


# ========================================
# DEMOSTRACIÓN
# ========================================

if __name__ == "__main__":
    analizador = AnalizadorHTTP()
    
    urls_prueba = [
        'https://www.google.com',
        'https://github.com',
        'https://httpbin.org/get',
    ]
    
    for url in urls_prueba:
        resultado = analizador.analizar_url(url)
        analizador.imprimir_analisis(resultado)</code></pre>

        <h2>3.3 Web Scraping con BeautifulSoup</h2>

        <p><strong>BeautifulSoup</strong> es una biblioteca de Python para extraer datos de archivos HTML y XML. Es especialmente útil para web scraping y análisis de contenido web.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Web Scraping básico con BeautifulSoup
"""

import requests
from bs4 import BeautifulSoup
import re

# ========================================
# INSTALACIÓN
# ========================================

# pip install beautifulsoup4
# pip install lxml  (parser más rápido, opcional)

# ========================================
# FUNDAMENTOS DE BEAUTIFULSOUP
# ========================================

def demo_beautifulsoup():
    """Demostración de funciones básicas de BeautifulSoup."""
    
    # HTML de ejemplo
    html = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Página de Ejemplo</title>
        <meta name="author" content="Admin">
    </head>
    <body>
        <div id="header">
            <h1 class="titulo">Bienvenido</h1>
            <nav>
                <a href="/home">Inicio</a>
                <a href="/about">Acerca</a>
                <a href="/contact">Contacto</a>
            </nav>
        </div>
        
        <div id="content">
            <article class="post">
                <h2>Primer Post</h2>
                <p class="meta">Autor: <span class="author">Juan</span></p>
                <p>Contenido del primer post...</p>
            </article>
            
            <article class="post">
                <h2>Segundo Post</h2>
                <p class="meta">Autor: <span class="author">María</span></p>
                <p>Contenido del segundo post...</p>
            </article>
        </div>
        
        <form action="/login" method="post">
            <input type="text" name="username" id="user">
            <input type="password" name="password" id="pass">
            <input type="submit" value="Login">
        </form>
        
        <footer>
            <p>Email: <a href="mailto:admin@example.com">admin@example.com</a></p>
        </footer>
    </body>
    </html>
    """
    
    # Crear objeto BeautifulSoup
    soup = BeautifulSoup(html, 'html.parser')  # o 'lxml' para más velocidad
    
    print("=== BEAUTIFULSOUP FUNDAMENTOS ===\n")
    
    # ---- NAVEGACIÓN BÁSICA ----
    
    # Título de la página
    print(f"Título: {soup.title.text}")
    
    # Primer elemento de un tipo
    print(f"Primer <h1>: {soup.h1.text}")
    print(f"Primer <a>: {soup.a['href']}")
    
    # ---- BÚSQUEDA ----
    
    # find() - Primer elemento que coincide
    header = soup.find('div', id='header')
    print(f"\nDiv con id='header': {header.h1.text}")
    
    # find_all() - Todos los elementos
    links = soup.find_all('a')
    print(f"\nTodos los links ({len(links)}):")
    for link in links:
        print(f"  - {link.get('href')}: {link.text}")
    
    # Por clase
    posts = soup.find_all('article', class_='post')
    print(f"\nArtículos con class='post': {len(posts)}")
    
    # ---- SELECTORES CSS ----
    
    print("\n--- SELECTORES CSS ---")
    
    # select() usa sintaxis CSS
    autores = soup.select('span.author')
    print(f"Autores (span.author): {[a.text for a in autores]}")
    
    # Selector más complejo
    nav_links = soup.select('nav a')
    print(f"Links en nav: {[a.text for a in nav_links]}")
    
    # Por ID
    content = soup.select_one('#content')
    print(f"Div #content existe: {content is not None}")
    
    # ---- ATRIBUTOS ----
    
    print("\n--- ATRIBUTOS ---")
    
    # Obtener atributos
    form = soup.find('form')
    print(f"Form action: {form.get('action')}")
    print(f"Form method: {form.get('method')}")
    
    # Todos los atributos
    inputs = soup.find_all('input')
    for inp in inputs:
        print(f"  Input: type={inp.get('type')}, name={inp.get('name')}")
    
    # ---- TEXTO ----
    
    print("\n--- EXTRACCIÓN DE TEXTO ---")
    
    # .text - Todo el texto interno
    primer_post = soup.find('article')
    print(f"Texto del primer post:\n{primer_post.get_text(strip=True)[:100]}")
    
    # .string - Solo si hay un único hijo de texto
    h1 = soup.find('h1')
    print(f"String de h1: {h1.string}")
    
    # ---- NAVEGACIÓN DEL ÁRBOL ----
    
    print("\n--- NAVEGACIÓN ---")
    
    articulo = soup.find('article')
    print(f"Padre de article: {articulo.parent.name}")
    print(f"Siguiente hermano: {articulo.find_next_sibling('article').h2.text}")


# ========================================
# SCRAPING PRÁCTICO
# ========================================

def extraer_informacion_web(url):
    """
    Extrae información útil de una página web.
    Útil para reconocimiento en pentesting.
    """
    try:
        response = requests.get(url, timeout=10, headers={
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        response.raise_for_status()
    except Exception as e:
        return {'error': str(e)}
    
    soup = BeautifulSoup(response.text, 'html.parser')
    
    info = {
        'url': url,
        'titulo': None,
        'meta_tags': {},
        'links_internos': [],
        'links_externos': [],
        'emails': [],
        'formularios': [],
        'scripts': [],
        'comentarios': []
    }
    
    # Título
    if soup.title:
        info['titulo'] = soup.title.text.strip()
    
    # Meta tags
    for meta in soup.find_all('meta'):
        nombre = meta.get('name') or meta.get('property', '')
        contenido = meta.get('content', '')
        if nombre and contenido:
            info['meta_tags'][nombre] = contenido[:200]
    
    # Links
    from urllib.parse import urljoin, urlparse
    dominio_base = urlparse(url).netloc
    
    for link in soup.find_all('a', href=True):
        href = link['href']
        href_completo = urljoin(url, href)
        
        if urlparse(href_completo).netloc == dominio_base:
            if href_completo not in info['links_internos']:
                info['links_internos'].append(href_completo)
        elif href.startswith('http'):
            if href not in info['links_externos']:
                info['links_externos'].append(href)
    
    # Emails
    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
    emails = re.findall(email_pattern, response.text)
    info['emails'] = list(set(emails))
    
    # Formularios
    for form in soup.find_all('form'):
        form_info = {
            'action': form.get('action', ''),
            'method': form.get('method', 'get').upper(),
            'inputs': []
        }
        for inp in form.find_all(['input', 'textarea', 'select']):
            form_info['inputs'].append({
                'type': inp.get('type', 'text'),
                'name': inp.get('name', ''),
                'id': inp.get('id', '')
            })
        info['formularios'].append(form_info)
    
    # Scripts externos
    for script in soup.find_all('script', src=True):
        src = script['src']
        if src.startswith('http'):
            info['scripts'].append(src)
        else:
            info['scripts'].append(urljoin(url, src))
    
    # Comentarios HTML (pueden contener info sensible)
    from bs4 import Comment
    comentarios = soup.find_all(string=lambda text: isinstance(text, Comment))
    info['comentarios'] = [c.strip()[:200] for c in comentarios if c.strip()]
    
    return info


def imprimir_info_web(info):
    """Imprime la información extraída."""
    print(f"\n{'='*60}")
    print(f"  INFORMACIÓN EXTRAÍDA: {info.get('url', 'N/A')}")
    print(f"{'='*60}\n")
    
    if 'error' in info:
        print(f"[-] Error: {info['error']}")
        return
    
    print(f"[+] Título: {info['titulo']}")
    
    if info['meta_tags']:
        print(f"\n[*] Meta Tags importantes:")
        for nombre in ['description', 'keywords', 'author', 'generator']:
            if nombre in info['meta_tags']:
                print(f"    {nombre}: {info['meta_tags'][nombre][:80]}")
    
    print(f"\n[*] Links internos: {len(info['links_internos'])}")
    for link in info['links_internos'][:10]:
        print(f"    - {link}")
    
    print(f"\n[*] Links externos: {len(info['links_externos'])}")
    for link in info['links_externos'][:5]:
        print(f"    - {link}")
    
    if info['emails']:
        print(f"\n[*] Emails encontrados: {info['emails']}")
    
    if info['formularios']:
        print(f"\n[*] Formularios ({len(info['formularios'])}):")
        for form in info['formularios']:
            print(f"    Form: {form['method']} {form['action']}")
            for inp in form['inputs'][:5]:
                print(f"      - {inp['type']}: {inp['name']}")
    
    if info['comentarios']:
        print(f"\n[!] Comentarios HTML ({len(info['comentarios'])}):")
        for com in info['comentarios'][:3]:
            print(f"    <!-- {com[:60]}... -->")
    
    print(f"\n{'='*60}")


# ========================================
# MAIN
# ========================================

if __name__ == "__main__":
    # Demo de fundamentos
    demo_beautifulsoup()
    
    # Ejemplo práctico
    print("\n" + "="*60)
    print("  EJEMPLO PRÁCTICO")
    print("="*60)
    
    url = "https://example.com"
    info = extraer_informacion_web(url)
    imprimir_info_web(info)</code></pre>

        <h2>3.4 Práctica: Verificador de Cabeceras de Seguridad HTTP</h2>

        <p>Esta herramienta analiza las cabeceras de seguridad HTTP de un sitio web y proporciona una puntuación basada en las mejores prácticas de seguridad.</p>

        <blockquote>
            <strong>Importante:</strong> Los headers de seguridad HTTP son una primera línea de defensa contra varios tipos de ataques web como XSS, clickjacking y MIME sniffing.
        </blockquote>

        <p>El código completo de esta práctica está disponible en el material del curso. Incluye análisis de:</p>

        <ul>
            <li><strong>HSTS</strong> (Strict-Transport-Security)</li>
            <li><strong>CSP</strong> (Content-Security-Policy)</li>
            <li><strong>X-Frame-Options</strong></li>
            <li><strong>X-Content-Type-Options</strong></li>
            <li><strong>Referrer-Policy</strong></li>
            <li><strong>Permissions-Policy</strong></li>
            <li>Análisis de cookies (Secure, HttpOnly, SameSite)</li>
            <li>Detección de headers que revelan información</li>
        </ul>

        <h2>Resumen de la Sesión 4</h2>

        <h3>Conceptos Cubiertos</h3>

        <table>
            <thead>
                <tr>
                    <th>Tema</th>
                    <th>Módulos/Funciones</th>
                    <th>Aplicación en Ciberseguridad</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Sockets TCP/UDP</td>
                    <td>socket.socket(), connect(), bind(), listen()</td>
                    <td>Comunicación de red, herramientas custom</td>
                </tr>
                <tr>
                    <td>Cliente-Servidor</td>
                    <td>accept(), send(), recv()</td>
                    <td>Backdoors, C2, chat seguro</td>
                </tr>
                <tr>
                    <td>Escaneo de puertos</td>
                    <td>connect_ex(), settimeout()</td>
                    <td>Reconocimiento, descubrimiento de servicios</td>
                </tr>
                <tr>
                    <td>Banner grabbing</td>
                    <td>recv(), SSL/TLS</td>
                    <td>Fingerprinting, identificación de versiones</td>
                </tr>
                <tr>
                    <td>Multithreading</td>
                    <td>threading, ThreadPoolExecutor</td>
                    <td>Escaneo concurrente, eficiencia</td>
                </tr>
                <tr>
                    <td>HTTP/Requests</td>
                    <td>requests.get/post, headers, cookies</td>
                    <td>Web testing, API testing</td>
                </tr>
                <tr>
                    <td>Web Scraping</td>
                    <td>BeautifulSoup, selectores CSS</td>
                    <td>OSINT, extracción de datos</td>
                </tr>
                <tr>
                    <td>Headers de seguridad</td>
                    <td>Análisis de respuestas HTTP</td>
                    <td>Auditoría de configuración</td>
                </tr>
            </tbody>
        </table>

        <h3>Herramientas Creadas</h3>

        <ol>
            <li><strong>Chat TCP</strong>: Cliente-servidor con múltiples usuarios</li>
            <li><strong>Escáner de puertos</strong>: Simple y multihilo</li>
            <li><strong>Banner Grabber</strong>: Identificación de servicios</li>
            <li><strong>Analizador HTTP</strong>: Tecnologías y configuración</li>
            <li><strong>Verificador de seguridad</strong>: Headers HTTP y cookies</li>
        </ol>

        <h3>Puertos Importantes para Recordar</h3>

        <table>
            <thead>
                <tr>
                    <th>Puerto</th>
                    <th>Servicio</th>
                    <th>Importancia</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>21</td>
                    <td>FTP</td>
                    <td>Transferencia archivos, credenciales en claro</td>
                </tr>
                <tr>
                    <td>22</td>
                    <td>SSH</td>
                    <td>Acceso remoto seguro</td>
                </tr>
                <tr>
                    <td>23</td>
                    <td>Telnet</td>
                    <td>Acceso remoto inseguro</td>
                </tr>
                <tr>
                    <td>80/443</td>
                    <td>HTTP/S</td>
                    <td>Servicios web</td>
                </tr>
                <tr>
                    <td>445</td>
                    <td>SMB</td>
                    <td>Compartición archivos Windows</td>
                </tr>
                <tr>
                    <td>3306</td>
                    <td>MySQL</td>
                    <td>Base de datos</td>
                </tr>
                <tr>
                    <td>3389</td>
                    <td>RDP</td>
                    <td>Escritorio remoto Windows</td>
                </tr>
            </tbody>
        </table>

        <h3>Ejercicios Adicionales</h3>

        <ol>
            <li><strong>Escáner SYN</strong>: Implementar escaneo SYN con Scapy (requiere root)</li>
            <li><strong>Fuzzer de directorios</strong>: Buscar rutas ocultas en servidores web</li>
            <li><strong>Verificador de SSL</strong>: Analizar configuración TLS/certificados</li>
            <li><strong>Crawler</strong>: Rastrear sitio web completo extrayendo información</li>
            <li><strong>Detector de WAF</strong>: Identificar Web Application Firewalls</li>
        </ol>

    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>