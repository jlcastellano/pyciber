<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SESIÓN 3: Archivos, Expresiones Regulares y OS</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>SESIÓN 3: Archivos, Expresiones Regulares y OS</div>
    </header>

    <section class="contenido-didactico">

        <h1>BLOQUE 2: Expresiones Regulares</h1>

        <h2>2.1 Fundamentos del Módulo re</h2>

        <p>Las expresiones regulares son patrones para buscar y manipular texto. Esenciales para parsing de logs, extracción de datos y validación.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Fundamentos de expresiones regulares con el módulo re
"""

import re

# ========================================
# FUNCIONES PRINCIPALES
# ========================================

texto = "Mi IP es 192.168.1.100 y el servidor está en 10.0.0.1"

# re.search() - Busca la PRIMERA coincidencia
# Retorna Match object o None
resultado = re.search(r'\d+\.\d+\.\d+\.\d+', texto)
if resultado:
    print(f"search() encontró: {resultado.group()}")
    print(f"  Posición: {resultado.start()} - {resultado.end()}")
    print(f"  Span: {resultado.span()}")

# re.match() - Busca SOLO al inicio del string
resultado = re.match(r'Mi', texto)
print(f"\nmatch('Mi'): {resultado.group() if resultado else 'No encontrado'}")

resultado = re.match(r'\d+', texto)  # No empieza con número
print(f"match('\\d+'): {resultado.group() if resultado else 'No encontrado'}")

# re.findall() - Encuentra TODAS las coincidencias (retorna lista)
ips = re.findall(r'\d+\.\d+\.\d+\.\d+', texto)
print(f"\nfindall() IPs: {ips}")

# re.finditer() - Encuentra todas, retorna iterador de Match objects
print("\nfinditer() IPs:")
for match in re.finditer(r'\d+\.\d+\.\d+\.\d+', texto):
    print(f"  {match.group()} en posición {match.span()}")

# re.sub() - Sustituir coincidencias
texto_censurado = re.sub(r'\d+\.\d+\.\d+\.\d+', '[IP OCULTA]', texto)
print(f"\nsub(): {texto_censurado}")

# re.split() - Dividir por patrón
log = "ERROR:2024-01-15:192.168.1.1:Conexión fallida"
partes = re.split(r':', log)
print(f"\nsplit(): {partes}")

# Limitar splits
partes = re.split(r':', log, maxsplit=2)
print(f"split(maxsplit=2): {partes}")

# ========================================
# COMPILAR EXPRESIONES
# ========================================

# Para patrones que se usan múltiples veces, compilar es más eficiente
patron_ip = re.compile(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')

textos = [
    "Servidor: 192.168.1.1",
    "Cliente: 10.0.0.50",
    "Sin IP aquí",
    "Gateway: 172.16.0.1"
]

print("\nUsando patrón compilado:")
for t in textos:
    match = patron_ip.search(t)
    if match:
        print(f"  '{t}' -> {match.group()}")</code></pre>

        <h2>2.2 Metacaracteres y Patrones</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Metacaracteres y patrones de expresiones regulares
"""

import re

# ========================================
# METACARACTERES BÁSICOS
# ========================================

print("=== METACARACTERES BÁSICOS ===\n")

texto = "abc123 ABC456 a1b2c3 test@email.com 192.168.1.1"

# . (punto) - Cualquier carácter excepto newline
print(f"Patrón 'a.c': {re.findall(r'a.c', texto)}")  # abc

# \d - Dígito [0-9]
print(f"Patrón '\\d+': {re.findall(r'\d+', texto)}")

# \D - NO dígito
print(f"Patrón '\\D+': {re.findall(r'\D+', texto)}")

# \w - Alfanumérico [a-zA-Z0-9_]
print(f"Patrón '\\w+': {re.findall(r'\w+', texto)}")

# \W - NO alfanumérico
print(f"Patrón '\\W+': {re.findall(r'\W+', texto)}")

# \s - Espacio en blanco (espacio, tab, newline)
print(f"Patrón '\\s+': {re.findall(r'\s+', 'hola   mundo\ttab')}")

# \S - NO espacio en blanco
print(f"Patrón '\\S+': {re.findall(r'\S+', 'hola   mundo')}")

# ========================================
# CUANTIFICADORES
# ========================================

print("\n=== CUANTIFICADORES ===\n")

texto = "a aa aaa aaaa b bb bbb"

# * - Cero o más
print(f"'a*': {re.findall(r'a*', texto)}")  # Incluye strings vacíos

# + - Uno o más
print(f"'a+': {re.findall(r'a+', texto)}")

# ? - Cero o uno
print(f"'a?': {re.findall(r'a?', texto)}")

# {n} - Exactamente n
print(f"'a{{2}}': {re.findall(r'a{2}', texto)}")

# {n,m} - Entre n y m
print(f"'a{{2,3}}': {re.findall(r'a{2,3}', texto)}")

# {n,} - n o más
print(f"'a{{2,}}': {re.findall(r'a{2,}', texto)}")

# Cuantificadores no codiciosos (lazy) con ?
html = "<tag>contenido</tag><tag>otro</tag>"
print(f"\nCodicioso '<.*>': {re.findall(r'<.*>', html)}")
print(f"No codicioso '<.*?>': {re.findall(r'<.*?>', html)}")

# ========================================
# ANCLAS
# ========================================

print("\n=== ANCLAS ===\n")

texto = "Python es genial"

# ^ - Inicio de string (o línea con MULTILINE)
print(f"'^Python': {re.search(r'^Python', texto)}")
print(f"'^genial': {re.search(r'^genial', texto)}")  # None

# $ - Final de string (o línea con MULTILINE)
print(f"'genial$': {re.search(r'genial$', texto)}")
print(f"'Python$': {re.search(r'Python$', texto)}")  # None

# \b - Límite de palabra
texto = "cat category caterpillar"
print(f"'\\bcat\\b': {re.findall(r'\bcat\b', texto)}")  # Solo 'cat'
print(f"'cat': {re.findall(r'cat', texto)}")  # Todos

# ========================================
# CLASES DE CARACTERES
# ========================================

print("\n=== CLASES DE CARACTERES ===\n")

texto = "abc123XYZ!@#"

# [abc] - Cualquiera de estos caracteres
print(f"'[aeiou]': {re.findall(r'[aeiou]', texto)}")

# [a-z] - Rango
print(f"'[a-z]': {re.findall(r'[a-z]', texto)}")
print(f"'[A-Z]': {re.findall(r'[A-Z]', texto)}")
print(f"'[0-9]': {re.findall(r'[0-9]', texto)}")

# [^abc] - Negación (cualquiera EXCEPTO estos)
print(f"'[^a-zA-Z]': {re.findall(r'[^a-zA-Z]', texto)}")

# Combinaciones
print(f"'[a-zA-Z0-9]': {re.findall(r'[a-zA-Z0-9]', texto)}")

# ========================================
# ALTERNANCIA Y AGRUPACIÓN
# ========================================

print("\n=== ALTERNANCIA Y AGRUPACIÓN ===\n")

texto = "Error: fallo en conexión. Warning: timeout. Info: OK"

# | - Alternancia (OR)
print(f"'Error|Warning': {re.findall(r'Error|Warning', texto)}")

# () - Grupos
# Sin grupos, findall retorna toda la coincidencia
print(f"'(Error|Warning):': {re.findall(r'(Error|Warning):', texto)}")

# Con grupos, findall retorna solo los grupos
log = "192.168.1.1 - GET /index.html - 200"
patron = r'(\d+\.\d+\.\d+\.\d+) - (\w+) (.*?) - (\d+)'
match = re.search(patron, log)
if match:
    print(f"\nMatch completo: {match.group(0)}")
    print(f"Grupo 1 (IP): {match.group(1)}")
    print(f"Grupo 2 (Método): {match.group(2)}")
    print(f"Grupo 3 (Ruta): {match.group(3)}")
    print(f"Grupo 4 (Código): {match.group(4)}")
    print(f"Todos los grupos: {match.groups()}")</code></pre>

        <h2>2.3 Patrones Comunes en Ciberseguridad</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Patrones regex comunes en ciberseguridad
"""

import re

# ========================================
# PATRONES COMUNES
# ========================================

patrones = {
    # Direcciones IP (IPv4)
    "ipv4": r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b',
    
    # IP simple (menos estricta)
    "ipv4_simple": r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b',
    
    # Direcciones IPv6 (simplificada)
    "ipv6": r'(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}',
    
    # Email
    "email": r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
    
    # URL
    "url": r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[/\w\-.?&=%]*',
    
    # Dominio
    "dominio": r'\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}\b',
    
    # Dirección MAC
    "mac": r'(?:[0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}',
    
    # Hash MD5
    "md5": r'\b[a-fA-F0-9]{32}\b',
    
    # Hash SHA256
    "sha256": r'\b[a-fA-F0-9]{64}\b',
    
    # Puerto
    "puerto": r'\b(?:[1-9]\d{0,3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])\b',
    
    # CVE
    "cve": r'CVE-\d{4}-\d{4,}',
    
    # Base64
    "base64": r'(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?',
    
    # JWT Token
    "jwt": r'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*',
}

# Compilar patrones
patrones_compilados = {nombre: re.compile(patron) for nombre, patron in patrones.items()}


def extraer_indicadores(texto):
    """
    Extrae indicadores de compromiso (IoC) de un texto.
    """
    resultados = {}
    
    for nombre, patron in patrones_compilados.items():
        matches = patron.findall(texto)
        if matches:
            resultados[nombre] = list(set(matches))  # Eliminar duplicados
    
    return resultados


# ========================================
# PRUEBA
# ========================================

texto_prueba = """
Reporte de incidente de seguridad

El atacante utilizó la IP 192.168.1.100 para realizar el ataque inicial.
También se detectaron conexiones desde 10.0.0.50 y 203.0.113.42.

Se encontraron los siguientes emails en los logs:
- admin@empresa.com
- hacker@malicious-domain.net
- soporte@empresa.com

URLs maliciosas detectadas:
- https://malware.bad-site.com/payload.exe
- http://phishing.example.com/login.php

Hashes de archivos sospechosos:
- MD5: 098f6bcd4621d373cade4e832627b4f6
- SHA256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

Vulnerabilidades explotadas:
- CVE-2024-1234
- CVE-2023-9999

Direcciones MAC de dispositivos comprometidos:
- 00:1A:2B:3C:4D:5E
- AA:BB:CC:DD:EE:FF
"""

print("=== EXTRACCIÓN DE INDICADORES DE COMPROMISO ===\n")

iocs = extraer_indicadores(texto_prueba)

for tipo, valores in iocs.items():
    if valores:
        print(f"[+] {tipo.upper()}:")
        for valor in valores[:5]:  # Limitar a 5 por tipo
            print(f"    - {valor}")
        if len(valores) > 5:
            print(f"    ... y {len(valores) - 5} más")
        print()</code></pre>

    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>