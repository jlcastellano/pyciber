<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SESIÓN 3: Archivos, Expresiones Regulares y OS</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>SESIÓN 3: Archivos, Expresiones Regulares y OS</div>
    </header>

    <section class="contenido-didactico">
        <h1>BLOQUE 1: Manejo de Archivos</h1>

        <h2>1.1 Fundamentos de Lectura y Escritura</h2>
        
        <p>El manejo de archivos es fundamental en ciberseguridad: logs, configuraciones, wordlists, resultados de escaneos, y más.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Fundamentos de manejo de archivos
"""

# ========================================
# ABRIR ARCHIVOS - MODOS BÁSICOS
# ========================================

# Modos de apertura:
# 'r'  - Lectura (default). Error si no existe.
# 'w'  - Escritura. Crea archivo o SOBRESCRIBE si existe.
# 'a'  - Append. Crea archivo o agrega al final si existe.
# 'x'  - Creación exclusiva. Error si ya existe.
# 'r+' - Lectura y escritura.
# 'b'  - Modo binario (agregar a otros modos: 'rb', 'wb')

# ========================================
# ESCRITURA BÁSICA
# ========================================

# Forma tradicional (NO recomendada)
archivo = open("ejemplo.txt", "w")
archivo.write("Primera línea\n")
archivo.write("Segunda línea\n")
archivo.close()  # ¡IMPORTANTE! Siempre cerrar

# Problema: si hay error antes de close(), el archivo queda abierto
# Solución: usar context manager (with)

# ========================================
# CONTEXT MANAGER (WITH) - FORMA RECOMENDADA
# ========================================

# El archivo se cierra automáticamente al salir del bloque
with open("log_seguridad.txt", "w") as archivo:
    archivo.write("=== LOG DE SEGURIDAD ===\n")
    archivo.write("2024-01-15 10:00:01 - Sistema iniciado\n")
    archivo.write("2024-01-15 10:00:02 - Firewall activo\n")
    archivo.write("2024-01-15 10:00:03 - Monitoreo iniciado\n")

print("[+] Archivo creado: log_seguridad.txt")

# ========================================
# LECTURA DE ARCHIVOS
# ========================================

# read() - Lee todo el contenido como string
with open("log_seguridad.txt", "r") as archivo:
    contenido = archivo.read()
    print("\n--- read() ---")
    print(contenido)

# readline() - Lee una línea a la vez
with open("log_seguridad.txt", "r") as archivo:
    print("--- readline() ---")
    linea1 = archivo.readline()
    linea2 = archivo.readline()
    print(f"Línea 1: {linea1.strip()}")
    print(f"Línea 2: {linea2.strip()}")

# readlines() - Lee todas las líneas como lista
with open("log_seguridad.txt", "r") as archivo:
    lineas = archivo.readlines()
    print("\n--- readlines() ---")
    print(f"Total líneas: {len(lineas)}")
    print(f"Lista: {lineas}")

# Iterar directamente (más eficiente en memoria)
with open("log_seguridad.txt", "r") as archivo:
    print("\n--- Iteración directa ---")
    for numero, linea in enumerate(archivo, 1):
        print(f"{numero}: {linea.strip()}")

# ========================================
# APPEND - AGREGAR AL FINAL
# ========================================

with open("log_seguridad.txt", "a") as archivo:
    archivo.write("2024-01-15 10:00:04 - Nuevo evento agregado\n")
    archivo.write("2024-01-15 10:00:05 - Conexión detectada\n")

print("\n[+] Líneas agregadas al archivo")

# Verificar
with open("log_seguridad.txt", "r") as archivo:
    print("\n--- Contenido actualizado ---")
    print(archivo.read())

# ========================================
# ESCRIBIR MÚLTIPLES LÍNEAS
# ========================================

eventos = [
    "ERROR: Intento de acceso fallido",
    "WARNING: Múltiples conexiones desde 192.168.1.100",
    "INFO: Backup completado",
    "CRITICAL: Posible intrusión detectada"
]

with open("alertas.txt", "w") as archivo:
    # Opción 1: writelines (no agrega saltos de línea)
    archivo.writelines(evento + "\n" for evento in eventos)

# Opción 2: write con join
with open("alertas2.txt", "w") as archivo:
    archivo.write("\n".join(eventos))

# ========================================
# VERIFICAR SI ARCHIVO EXISTE
# ========================================

import os

nombre_archivo = "log_seguridad.txt"

if os.path.exists(nombre_archivo):
    print(f"\n[+] El archivo '{nombre_archivo}' existe")
    print(f"    Tamaño: {os.path.getsize(nombre_archivo)} bytes")
else:
    print(f"[-] El archivo '{nombre_archivo}' no existe")

# Verificar si es archivo o directorio
print(f"    Es archivo: {os.path.isfile(nombre_archivo)}")
print(f"    Es directorio: {os.path.isdir(nombre_archivo)}")</code></pre>

        <h2>1.2 Archivos de Texto y Binarios</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Archivos de texto vs binarios
"""

import os

# ========================================
# ARCHIVOS DE TEXTO
# ========================================

# Especificar encoding (importante para compatibilidad)
with open("texto_utf8.txt", "w", encoding="utf-8") as f:
    f.write("Texto con caracteres especiales: áéíóú ñ €\n")
    f.write("日本語テキスト\n")  # Japonés

with open("texto_utf8.txt", "r", encoding="utf-8") as f:
    print("--- Texto UTF-8 ---")
    print(f.read())

# Error común: encoding incorrecto
try:
    with open("texto_utf8.txt", "r", encoding="ascii") as f:
        contenido = f.read()
except UnicodeDecodeError as e:
    print(f"[!] Error de encoding: {e}")

# ========================================
# ARCHIVOS BINARIOS
# ========================================

# Escribir datos binarios
datos_binarios = bytes([0x48, 0x65, 0x6c, 0x6c, 0x6f])  # "Hello" en bytes

with open("datos.bin", "wb") as f:
    f.write(datos_binarios)
    f.write(b"\x00\x01\x02\x03\x04")  # Bytes adicionales

# Leer datos binarios
with open("datos.bin", "rb") as f:
    contenido = f.read()
    print(f"\n--- Archivo binario ---")
    print(f"Bytes: {contenido}")
    print(f"Hex: {contenido.hex()}")
    print(f"Longitud: {len(contenido)} bytes")

# ========================================
# CASO PRÁCTICO: LEER CABECERA DE ARCHIVO
# ========================================

def identificar_tipo_archivo(ruta):
    """
    Identifica el tipo de archivo por sus magic bytes.
    """
    magic_bytes = {
        b'\x89PNG': 'PNG Image',
        b'\xff\xd8\xff': 'JPEG Image',
        b'GIF8': 'GIF Image',
        b'PK\x03\x04': 'ZIP Archive',
        b'%PDF': 'PDF Document',
        b'\x7fELF': 'ELF Executable',
        b'MZ': 'Windows Executable',
    }
    
    try:
        with open(ruta, 'rb') as f:
            cabecera = f.read(8)
        
        for magic, tipo in magic_bytes.items():
            if cabecera.startswith(magic):
                return tipo
        
        return "Desconocido o texto plano"
    
    except FileNotFoundError:
        return "Archivo no encontrado"
    except PermissionError:
        return "Sin permisos de lectura"

# Crear archivo de prueba simulando PNG
with open("fake_image.png", "wb") as f:
    f.write(b'\x89PNG\r\n\x1a\n')
    f.write(b'\x00' * 100)  # Datos simulados

print(f"\nTipo de archivo: {identificar_tipo_archivo('fake_image.png')}")
print(f"Tipo de datos.bin: {identificar_tipo_archivo('datos.bin')}")

# Limpiar archivos de prueba
for archivo in ["datos.bin", "fake_image.png"]:
    if os.path.exists(archivo):
        os.remove(archivo)</code></pre>

        <h2>1.3 Trabajo con CSV y JSON</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Trabajo con archivos CSV y JSON
"""

import csv
import json
from datetime import datetime

# ========================================
# ARCHIVOS CSV
# ========================================

# Datos de ejemplo: resultados de escaneo
resultados_escaneo = [
    {"ip": "192.168.1.1", "puerto": 22, "estado": "open", "servicio": "SSH"},
    {"ip": "192.168.1.1", "puerto": 80, "estado": "open", "servicio": "HTTP"},
    {"ip": "192.168.1.1", "puerto": 443, "estado": "open", "servicio": "HTTPS"},
    {"ip": "192.168.1.2", "puerto": 22, "estado": "open", "servicio": "SSH"},
    {"ip": "192.168.1.2", "puerto": 3306, "estado": "filtered", "servicio": "MySQL"},
]

# Escribir CSV
with open("escaneo.csv", "w", newline="", encoding="utf-8") as f:
    campos = ["ip", "puerto", "estado", "servicio"]
    writer = csv.DictWriter(f, fieldnames=campos)
    
    writer.writeheader()  # Escribe la fila de encabezados
    writer.writerows(resultados_escaneo)  # Escribe todas las filas

print("[+] Archivo CSV creado: escaneo.csv")

# Leer CSV como diccionarios
print("\n--- Leyendo CSV ---")
with open("escaneo.csv", "r", encoding="utf-8") as f:
    reader = csv.DictReader(f)
    
    for fila in reader:
        print(f"  {fila['ip']}:{fila['puerto']} -> {fila['estado']} ({fila['servicio']})")

# Leer CSV como listas
print("\n--- CSV como listas ---")
with open("escaneo.csv", "r", encoding="utf-8") as f:
    reader = csv.reader(f)
    encabezados = next(reader)  # Primera fila
    print(f"Encabezados: {encabezados}")
    
    for fila in reader:
        print(f"  Fila: {fila}")

# ========================================
# ARCHIVOS JSON
# ========================================

# Datos de ejemplo: informe de vulnerabilidades
informe = {
    "objetivo": "192.168.1.0/24",
    "fecha": datetime.now().isoformat(),
    "analista": "security_team",
    "resumen": {
        "hosts_escaneados": 254,
        "hosts_activos": 15,
        "vulnerabilidades_criticas": 3,
        "vulnerabilidades_altas": 7
    },
    "hosts": [
        {
            "ip": "192.168.1.1",
            "hostname": "router.local",
            "puertos": [22, 80, 443],
            "vulnerabilidades": [
                {"cve": "CVE-2024-0001", "severidad": "alta", "descripcion": "Buffer overflow en SSH"}
            ]
        },
        {
            "ip": "192.168.1.10",
            "hostname": "webserver.local",
            "puertos": [22, 80, 443, 8080],
            "vulnerabilidades": []
        }
    ],
    "configuracion": {
        "timeout": 5,
        "threads": 10,
        "verbose": True
    }
}

# Escribir JSON
with open("informe.json", "w", encoding="utf-8") as f:
    json.dump(informe, f, indent=4, ensure_ascii=False)

print("\n[+] Archivo JSON creado: informe.json")

# Leer JSON
with open("informe.json", "r", encoding="utf-8") as f:
    datos = json.load(f)

print("\n--- Leyendo JSON ---")
print(f"Objetivo: {datos['objetivo']}")
print(f"Fecha: {datos['fecha']}")
print(f"Hosts activos: {datos['resumen']['hosts_activos']}")
print(f"Vulnerabilidades críticas: {datos['resumen']['vulnerabilidades_criticas']}")

print("\nHosts encontrados:")
for host in datos['hosts']:
    vulns = len(host['vulnerabilidades'])
    print(f"  {host['ip']} ({host['hostname']}): {len(host['puertos'])} puertos, {vulns} vulns")

# ========================================
# CONVERSIÓN JSON <-> STRING
# ========================================

# Objeto Python a string JSON
diccionario = {"clave": "valor", "numero": 42}
json_string = json.dumps(diccionario)
print(f"\nPython a JSON string: {json_string}")

# String JSON a objeto Python
json_texto = '{"ip": "10.0.0.1", "estado": "activo"}'
objeto = json.loads(json_texto)
print(f"JSON string a Python: {objeto}")
print(f"Acceso a IP: {objeto['ip']}")

# JSON con formato legible
print("\nJSON formateado:")
print(json.dumps(informe["resumen"], indent=2))</code></pre>


    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>