<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SESIÓN 3: Archivos, Expresiones Regulares y OS</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>SESIÓN 3: Archivos, Expresiones Regulares y OS</div>
    </header>

    <section class="contenido-didactico">
        <h1>BLOQUE 1: Manejo de Archivos</h1>

        <h2>1.1 Fundamentos de Lectura y Escritura</h2>
        
        <p>El manejo de archivos es fundamental en ciberseguridad: logs, configuraciones, wordlists, resultados de escaneos, y más.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Fundamentos de manejo de archivos
"""

# ========================================
# ABRIR ARCHIVOS - MODOS BÁSICOS
# ========================================

# Modos de apertura:
# 'r'  - Lectura (default). Error si no existe.
# 'w'  - Escritura. Crea archivo o SOBRESCRIBE si existe.
# 'a'  - Append. Crea archivo o agrega al final si existe.
# 'x'  - Creación exclusiva. Error si ya existe.
# 'r+' - Lectura y escritura.
# 'b'  - Modo binario (agregar a otros modos: 'rb', 'wb')

# ========================================
# ESCRITURA BÁSICA
# ========================================

# Forma tradicional (NO recomendada)
archivo = open("ejemplo.txt", "w")
archivo.write("Primera línea\n")
archivo.write("Segunda línea\n")
archivo.close()  # ¡IMPORTANTE! Siempre cerrar

# Problema: si hay error antes de close(), el archivo queda abierto
# Solución: usar context manager (with)

# ========================================
# CONTEXT MANAGER (WITH) - FORMA RECOMENDADA
# ========================================

# El archivo se cierra automáticamente al salir del bloque
with open("log_seguridad.txt", "w") as archivo:
    archivo.write("=== LOG DE SEGURIDAD ===\n")
    archivo.write("2024-01-15 10:00:01 - Sistema iniciado\n")
    archivo.write("2024-01-15 10:00:02 - Firewall activo\n")
    archivo.write("2024-01-15 10:00:03 - Monitoreo iniciado\n")

print("[+] Archivo creado: log_seguridad.txt")

# ========================================
# LECTURA DE ARCHIVOS
# ========================================

# read() - Lee todo el contenido como string
with open("log_seguridad.txt", "r") as archivo:
    contenido = archivo.read()
    print("\n--- read() ---")
    print(contenido)

# readline() - Lee una línea a la vez
with open("log_seguridad.txt", "r") as archivo:
    print("--- readline() ---")
    linea1 = archivo.readline()
    linea2 = archivo.readline()
    print(f"Línea 1: {linea1.strip()}")
    print(f"Línea 2: {linea2.strip()}")

# readlines() - Lee todas las líneas como lista
with open("log_seguridad.txt", "r") as archivo:
    lineas = archivo.readlines()
    print("\n--- readlines() ---")
    print(f"Total líneas: {len(lineas)}")
    print(f"Lista: {lineas}")

# Iterar directamente (más eficiente en memoria)
with open("log_seguridad.txt", "r") as archivo:
    print("\n--- Iteración directa ---")
    for numero, linea in enumerate(archivo, 1):
        print(f"{numero}: {linea.strip()}")

# ========================================
# APPEND - AGREGAR AL FINAL
# ========================================

with open("log_seguridad.txt", "a") as archivo:
    archivo.write("2024-01-15 10:00:04 - Nuevo evento agregado\n")
    archivo.write("2024-01-15 10:00:05 - Conexión detectada\n")

print("\n[+] Líneas agregadas al archivo")

# Verificar
with open("log_seguridad.txt", "r") as archivo:
    print("\n--- Contenido actualizado ---")
    print(archivo.read())

# ========================================
# ESCRIBIR MÚLTIPLES LÍNEAS
# ========================================

eventos = [
    "ERROR: Intento de acceso fallido",
    "WARNING: Múltiples conexiones desde 192.168.1.100",
    "INFO: Backup completado",
    "CRITICAL: Posible intrusión detectada"
]

with open("alertas.txt", "w") as archivo:
    # Opción 1: writelines (no agrega saltos de línea)
    archivo.writelines(evento + "\n" for evento in eventos)

# Opción 2: write con join
with open("alertas2.txt", "w") as archivo:
    archivo.write("\n".join(eventos))

# ========================================
# VERIFICAR SI ARCHIVO EXISTE
# ========================================

import os

nombre_archivo = "log_seguridad.txt"

if os.path.exists(nombre_archivo):
    print(f"\n[+] El archivo '{nombre_archivo}' existe")
    print(f"    Tamaño: {os.path.getsize(nombre_archivo)} bytes")
else:
    print(f"[-] El archivo '{nombre_archivo}' no existe")

# Verificar si es archivo o directorio
print(f"    Es archivo: {os.path.isfile(nombre_archivo)}")
print(f"    Es directorio: {os.path.isdir(nombre_archivo)}")</code></pre>

        <h2>1.2 Archivos de Texto y Binarios</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Archivos de texto vs binarios
"""

import os

# ========================================
# ARCHIVOS DE TEXTO
# ========================================

# Especificar encoding (importante para compatibilidad)
with open("texto_utf8.txt", "w", encoding="utf-8") as f:
    f.write("Texto con caracteres especiales: áéíóú ñ €\n")
    f.write("日本語テキスト\n")  # Japonés

with open("texto_utf8.txt", "r", encoding="utf-8") as f:
    print("--- Texto UTF-8 ---")
    print(f.read())

# Error común: encoding incorrecto
try:
    with open("texto_utf8.txt", "r", encoding="ascii") as f:
        contenido = f.read()
except UnicodeDecodeError as e:
    print(f"[!] Error de encoding: {e}")

# ========================================
# ARCHIVOS BINARIOS
# ========================================

# Escribir datos binarios
datos_binarios = bytes([0x48, 0x65, 0x6c, 0x6c, 0x6f])  # "Hello" en bytes

with open("datos.bin", "wb") as f:
    f.write(datos_binarios)
    f.write(b"\x00\x01\x02\x03\x04")  # Bytes adicionales

# Leer datos binarios
with open("datos.bin", "rb") as f:
    contenido = f.read()
    print(f"\n--- Archivo binario ---")
    print(f"Bytes: {contenido}")
    print(f"Hex: {contenido.hex()}")
    print(f"Longitud: {len(contenido)} bytes")

# ========================================
# CASO PRÁCTICO: LEER CABECERA DE ARCHIVO
# ========================================

def identificar_tipo_archivo(ruta):
    """
    Identifica el tipo de archivo por sus magic bytes.
    """
    magic_bytes = {
        b'\x89PNG': 'PNG Image',
        b'\xff\xd8\xff': 'JPEG Image',
        b'GIF8': 'GIF Image',
        b'PK\x03\x04': 'ZIP Archive',
        b'%PDF': 'PDF Document',
        b'\x7fELF': 'ELF Executable',
        b'MZ': 'Windows Executable',
    }
    
    try:
        with open(ruta, 'rb') as f:
            cabecera = f.read(8)
        
        for magic, tipo in magic_bytes.items():
            if cabecera.startswith(magic):
                return tipo
        
        return "Desconocido o texto plano"
    
    except FileNotFoundError:
        return "Archivo no encontrado"
    except PermissionError:
        return "Sin permisos de lectura"

# Crear archivo de prueba simulando PNG
with open("fake_image.png", "wb") as f:
    f.write(b'\x89PNG\r\n\x1a\n')
    f.write(b'\x00' * 100)  # Datos simulados

print(f"\nTipo de archivo: {identificar_tipo_archivo('fake_image.png')}")
print(f"Tipo de datos.bin: {identificar_tipo_archivo('datos.bin')}")

# Limpiar archivos de prueba
for archivo in ["datos.bin", "fake_image.png"]:
    if os.path.exists(archivo):
        os.remove(archivo)</code></pre>

        <h2>1.3 Trabajo con CSV y JSON</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Trabajo con archivos CSV y JSON
"""

import csv
import json
from datetime import datetime

# ========================================
# ARCHIVOS CSV
# ========================================

# Datos de ejemplo: resultados de escaneo
resultados_escaneo = [
    {"ip": "192.168.1.1", "puerto": 22, "estado": "open", "servicio": "SSH"},
    {"ip": "192.168.1.1", "puerto": 80, "estado": "open", "servicio": "HTTP"},
    {"ip": "192.168.1.1", "puerto": 443, "estado": "open", "servicio": "HTTPS"},
    {"ip": "192.168.1.2", "puerto": 22, "estado": "open", "servicio": "SSH"},
    {"ip": "192.168.1.2", "puerto": 3306, "estado": "filtered", "servicio": "MySQL"},
]

# Escribir CSV
with open("escaneo.csv", "w", newline="", encoding="utf-8") as f:
    campos = ["ip", "puerto", "estado", "servicio"]
    writer = csv.DictWriter(f, fieldnames=campos)
    
    writer.writeheader()  # Escribe la fila de encabezados
    writer.writerows(resultados_escaneo)  # Escribe todas las filas

print("[+] Archivo CSV creado: escaneo.csv")

# Leer CSV como diccionarios
print("\n--- Leyendo CSV ---")
with open("escaneo.csv", "r", encoding="utf-8") as f:
    reader = csv.DictReader(f)
    
    for fila in reader:
        print(f"  {fila['ip']}:{fila['puerto']} -> {fila['estado']} ({fila['servicio']})")

# Leer CSV como listas
print("\n--- CSV como listas ---")
with open("escaneo.csv", "r", encoding="utf-8") as f:
    reader = csv.reader(f)
    encabezados = next(reader)  # Primera fila
    print(f"Encabezados: {encabezados}")
    
    for fila in reader:
        print(f"  Fila: {fila}")

# ========================================
# ARCHIVOS JSON
# ========================================

# Datos de ejemplo: informe de vulnerabilidades
informe = {
    "objetivo": "192.168.1.0/24",
    "fecha": datetime.now().isoformat(),
    "analista": "security_team",
    "resumen": {
        "hosts_escaneados": 254,
        "hosts_activos": 15,
        "vulnerabilidades_criticas": 3,
        "vulnerabilidades_altas": 7
    },
    "hosts": [
        {
            "ip": "192.168.1.1",
            "hostname": "router.local",
            "puertos": [22, 80, 443],
            "vulnerabilidades": [
                {"cve": "CVE-2024-0001", "severidad": "alta", "descripcion": "Buffer overflow en SSH"}
            ]
        },
        {
            "ip": "192.168.1.10",
            "hostname": "webserver.local",
            "puertos": [22, 80, 443, 8080],
            "vulnerabilidades": []
        }
    ],
    "configuracion": {
        "timeout": 5,
        "threads": 10,
        "verbose": True
    }
}

# Escribir JSON
with open("informe.json", "w", encoding="utf-8") as f:
    json.dump(informe, f, indent=4, ensure_ascii=False)

print("\n[+] Archivo JSON creado: informe.json")

# Leer JSON
with open("informe.json", "r", encoding="utf-8") as f:
    datos = json.load(f)

print("\n--- Leyendo JSON ---")
print(f"Objetivo: {datos['objetivo']}")
print(f"Fecha: {datos['fecha']}")
print(f"Hosts activos: {datos['resumen']['hosts_activos']}")
print(f"Vulnerabilidades críticas: {datos['resumen']['vulnerabilidades_criticas']}")

print("\nHosts encontrados:")
for host in datos['hosts']:
    vulns = len(host['vulnerabilidades'])
    print(f"  {host['ip']} ({host['hostname']}): {len(host['puertos'])} puertos, {vulns} vulns")

# ========================================
# CONVERSIÓN JSON <-> STRING
# ========================================

# Objeto Python a string JSON
diccionario = {"clave": "valor", "numero": 42}
json_string = json.dumps(diccionario)
print(f"\nPython a JSON string: {json_string}")

# String JSON a objeto Python
json_texto = '{"ip": "10.0.0.1", "estado": "activo"}'
objeto = json.loads(json_texto)
print(f"JSON string a Python: {objeto}")
print(f"Acceso a IP: {objeto['ip']}")

# JSON con formato legible
print("\nJSON formateado:")
print(json.dumps(informe["resumen"], indent=2))</code></pre>

        <h2>1.4 Práctica: Parser de Logs de Acceso</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Práctica: Parser de logs de autenticación (auth.log simulado)
"""

from datetime import datetime
from collections import Counter
import json

# Crear archivo de log simulado
logs_auth = """Jan 15 10:00:01 servidor sshd[1234]: Accepted password for admin from 192.168.1.100 port 52341 ssh2
Jan 15 10:00:15 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:00:16 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:00:17 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:00:18 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:00:19 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:01:00 servidor sshd[1236]: Accepted publickey for developer from 192.168.1.50 port 33421 ssh2
Jan 15 10:02:30 servidor sshd[1237]: Failed password for invalid user test from 203.0.113.100 port 12345 ssh2
Jan 15 10:02:31 servidor sshd[1237]: Failed password for invalid user admin from 203.0.113.100 port 12346 ssh2
Jan 15 10:02:32 servidor sshd[1237]: Failed password for invalid user guest from 203.0.113.100 port 12347 ssh2
Jan 15 10:05:00 servidor sshd[1238]: Accepted password for backup from 192.168.1.200 port 45678 ssh2
Jan 15 10:10:00 servidor sudo[1240]: admin : TTY=pts/0 ; PWD=/home/admin ; USER=root ; COMMAND=/bin/cat /etc/shadow
Jan 15 10:15:00 servidor sshd[1241]: Failed password for root from 10.0.0.50 port 43220 ssh2
Jan 15 10:15:01 servidor sshd[1241]: Failed password for root from 10.0.0.50 port 43220 ssh2
Jan 15 10:20:00 servidor sshd[1242]: Accepted password for webmaster from 192.168.1.75 port 54321 ssh2"""

# Guardar log simulado
with open("auth.log", "w") as f:
    f.write(logs_auth)


def parsear_log_ssh(linea):
    """
    Parsea una línea de log SSH y extrae información relevante.
    
    Returns:
        dict o None si no es una línea de SSH
    """
    if "sshd" not in linea:
        return None
    
    resultado = {
        "timestamp": None,
        "tipo": None,
        "usuario": None,
        "ip": None,
        "puerto": None,
        "metodo": None
    }
    
    # Extraer timestamp (formato simplificado)
    partes = linea.split()
    if len(partes) >= 3:
        resultado["timestamp"] = f"{partes[0]} {partes[1]} {partes[2]}"
    
    # Determinar tipo de evento
    if "Accepted" in linea:
        resultado["tipo"] = "exitoso"
        
        # Extraer método de autenticación
        if "password" in linea:
            resultado["metodo"] = "password"
        elif "publickey" in linea:
            resultado["metodo"] = "publickey"
        
        # Extraer usuario e IP
        try:
            if "for" in linea and "from" in linea:
                idx_for = linea.index("for") + 4
                idx_from = linea.index("from")
                resultado["usuario"] = linea[idx_for:idx_from].strip()
                
                # Extraer IP y puerto
                resto = linea[idx_from + 5:].split()
                resultado["ip"] = resto[0]
                if "port" in linea:
                    idx_port = resto.index("port")
                    resultado["puerto"] = int(resto[idx_port + 1])
        except (ValueError, IndexError):
            pass
            
    elif "Failed" in linea:
        resultado["tipo"] = "fallido"
        resultado["metodo"] = "password"
        
        # Verificar si es usuario inválido
        if "invalid user" in linea:
            resultado["usuario_invalido"] = True
            try:
                idx = linea.index("invalid user") + 13
                resto = linea[idx:].split()
                resultado["usuario"] = resto[0]
                idx_from = resto.index("from")
                resultado["ip"] = resto[idx_from + 1]
            except (ValueError, IndexError):
                pass
        else:
            resultado["usuario_invalido"] = False
            try:
                idx_for = linea.index("for") + 4
                idx_from = linea.index("from")
                resultado["usuario"] = linea[idx_for:idx_from].strip()
                resto = linea[idx_from + 5:].split()
                resultado["ip"] = resto[0]
            except (ValueError, IndexError):
                pass
    
    return resultado


def analizar_logs(ruta_archivo):
    """
    Analiza un archivo de logs y genera estadísticas.
    """
    estadisticas = {
        "total_eventos": 0,
        "logins_exitosos": 0,
        "logins_fallidos": 0,
        "ips_con_fallos": Counter(),
        "usuarios_atacados": Counter(),
        "usuarios_exitosos": [],
        "posibles_ataques": []
    }
    
    with open(ruta_archivo, "r") as f:
        for linea in f:
            resultado = parsear_log_ssh(linea.strip())
            
            if resultado is None:
                continue
            
            estadisticas["total_eventos"] += 1
            
            if resultado["tipo"] == "exitoso":
                estadisticas["logins_exitosos"] += 1
                estadisticas["usuarios_exitosos"].append({
                    "usuario": resultado["usuario"],
                    "ip": resultado["ip"],
                    "metodo": resultado["metodo"],
                    "timestamp": resultado["timestamp"]
                })
            
            elif resultado["tipo"] == "fallido":
                estadisticas["logins_fallidos"] += 1
                if resultado["ip"]:
                    estadisticas["ips_con_fallos"][resultado["ip"]] += 1
                if resultado["usuario"]:
                    estadisticas["usuarios_atacados"][resultado["usuario"]] += 1
    
    # Detectar posibles ataques de fuerza bruta (más de 3 fallos desde misma IP)
    for ip, count in estadisticas["ips_con_fallos"].items():
        if count >= 3:
            estadisticas["posibles_ataques"].append({
                "ip": ip,
                "intentos_fallidos": count,
                "tipo": "Posible fuerza bruta"
            })
    
    return estadisticas


def generar_informe(estadisticas, ruta_salida="informe_auth.json"):
    """
    Genera un informe en formato JSON.
    """
    # Convertir Counters a diccionarios para JSON
    informe = {
        "fecha_analisis": datetime.now().isoformat(),
        "resumen": {
            "total_eventos_ssh": estadisticas["total_eventos"],
            "logins_exitosos": estadisticas["logins_exitosos"],
            "logins_fallidos": estadisticas["logins_fallidos"],
            "tasa_exito": round(
                estadisticas["logins_exitosos"] / max(estadisticas["total_eventos"], 1) * 100, 2
            )
        },
        "logins_exitosos": estadisticas["usuarios_exitosos"],
        "top_ips_fallidas": dict(estadisticas["ips_con_fallos"].most_common(10)),
        "top_usuarios_atacados": dict(estadisticas["usuarios_atacados"].most_common(10)),
        "alertas": estadisticas["posibles_ataques"]
    }
    
    with open(ruta_salida, "w", encoding="utf-8") as f:
        json.dump(informe, f, indent=4, ensure_ascii=False)
    
    return informe


# ========================================
# EJECUTAR ANÁLISIS
# ========================================

print("=" * 60)
print("   ANALIZADOR DE LOGS DE AUTENTICACIÓN")
print("=" * 60)

# Analizar logs
stats = analizar_logs("auth.log")

# Mostrar resultados
print(f"\n[*] RESUMEN DE EVENTOS SSH:")
print(f"    Total eventos: {stats['total_eventos']}")
print(f"    Logins exitosos: {stats['logins_exitosos']}")
print(f"    Logins fallidos: {stats['logins_fallidos']}")

print(f"\n[*] TOP IPs CON INTENTOS FALLIDOS:")
for ip, count in stats["ips_con_fallos"].most_common(5):
    print(f"    {ip}: {count} intentos")

print(f"\n[*] USUARIOS MÁS ATACADOS:")
for usuario, count in stats["usuarios_atacados"].most_common(5):
    print(f"    {usuario}: {count} intentos")

print(f"\n[*] LOGINS EXITOSOS:")
for login in stats["usuarios_exitosos"]:
    print(f"    {login['usuario']} desde {login['ip']} ({login['metodo']})")

if stats["posibles_ataques"]:
    print(f"\n[!] ALERTAS DE SEGURIDAD:")
    for alerta in stats["posibles_ataques"]:
        print(f"    ⚠ {alerta['tipo']}: {alerta['ip']} ({alerta['intentos_fallidos']} intentos)")

# Generar informe JSON
informe = generar_informe(stats)
print(f"\n[+] Informe generado: informe_auth.json")

print("\n" + "=" * 60)</code></pre>

        <h1>BLOQUE 2: Expresiones Regulares</h1>

        <h2>2.1 Fundamentos del Módulo re</h2>

        <p>Las expresiones regulares son patrones para buscar y manipular texto. Esenciales para parsing de logs, extracción de datos y validación.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Fundamentos de expresiones regulares con el módulo re
"""

import re

# ========================================
# FUNCIONES PRINCIPALES
# ========================================

texto = "Mi IP es 192.168.1.100 y el servidor está en 10.0.0.1"

# re.search() - Busca la PRIMERA coincidencia
# Retorna Match object o None
resultado = re.search(r'\d+\.\d+\.\d+\.\d+', texto)
if resultado:
    print(f"search() encontró: {resultado.group()}")
    print(f"  Posición: {resultado.start()} - {resultado.end()}")
    print(f"  Span: {resultado.span()}")

# re.match() - Busca SOLO al inicio del string
resultado = re.match(r'Mi', texto)
print(f"\nmatch('Mi'): {resultado.group() if resultado else 'No encontrado'}")

resultado = re.match(r'\d+', texto)  # No empieza con número
print(f"match('\\d+'): {resultado.group() if resultado else 'No encontrado'}")

# re.findall() - Encuentra TODAS las coincidencias (retorna lista)
ips = re.findall(r'\d+\.\d+\.\d+\.\d+', texto)
print(f"\nfindall() IPs: {ips}")

# re.finditer() - Encuentra todas, retorna iterador de Match objects
print("\nfinditer() IPs:")
for match in re.finditer(r'\d+\.\d+\.\d+\.\d+', texto):
    print(f"  {match.group()} en posición {match.span()}")

# re.sub() - Sustituir coincidencias
texto_censurado = re.sub(r'\d+\.\d+\.\d+\.\d+', '[IP OCULTA]', texto)
print(f"\nsub(): {texto_censurado}")

# re.split() - Dividir por patrón
log = "ERROR:2024-01-15:192.168.1.1:Conexión fallida"
partes = re.split(r':', log)
print(f"\nsplit(): {partes}")

# Limitar splits
partes = re.split(r':', log, maxsplit=2)
print(f"split(maxsplit=2): {partes}")

# ========================================
# COMPILAR EXPRESIONES
# ========================================

# Para patrones que se usan múltiples veces, compilar es más eficiente
patron_ip = re.compile(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')

textos = [
    "Servidor: 192.168.1.1",
    "Cliente: 10.0.0.50",
    "Sin IP aquí",
    "Gateway: 172.16.0.1"
]

print("\nUsando patrón compilado:")
for t in textos:
    match = patron_ip.search(t)
    if match:
        print(f"  '{t}' -> {match.group()}")</code></pre>

        <h2>2.2 Metacaracteres y Patrones</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Metacaracteres y patrones de expresiones regulares
"""

import re

# ========================================
# METACARACTERES BÁSICOS
# ========================================

print("=== METACARACTERES BÁSICOS ===\n")

texto = "abc123 ABC456 a1b2c3 test@email.com 192.168.1.1"

# . (punto) - Cualquier carácter excepto newline
print(f"Patrón 'a.c': {re.findall(r'a.c', texto)}")  # abc

# \d - Dígito [0-9]
print(f"Patrón '\\d+': {re.findall(r'\d+', texto)}")

# \D - NO dígito
print(f"Patrón '\\D+': {re.findall(r'\D+', texto)}")

# \w - Alfanumérico [a-zA-Z0-9_]
print(f"Patrón '\\w+': {re.findall(r'\w+', texto)}")

# \W - NO alfanumérico
print(f"Patrón '\\W+': {re.findall(r'\W+', texto)}")

# \s - Espacio en blanco (espacio, tab, newline)
print(f"Patrón '\\s+': {re.findall(r'\s+', 'hola   mundo\ttab')}")

# \S - NO espacio en blanco
print(f"Patrón '\\S+': {re.findall(r'\S+', 'hola   mundo')}")

# ========================================
# CUANTIFICADORES
# ========================================

print("\n=== CUANTIFICADORES ===\n")

texto = "a aa aaa aaaa b bb bbb"

# * - Cero o más
print(f"'a*': {re.findall(r'a*', texto)}")  # Incluye strings vacíos

# + - Uno o más
print(f"'a+': {re.findall(r'a+', texto)}")

# ? - Cero o uno
print(f"'a?': {re.findall(r'a?', texto)}")

# {n} - Exactamente n
print(f"'a{{2}}': {re.findall(r'a{2}', texto)}")

# {n,m} - Entre n y m
print(f"'a{{2,3}}': {re.findall(r'a{2,3}', texto)}")

# {n,} - n o más
print(f"'a{{2,}}': {re.findall(r'a{2,}', texto)}")

# Cuantificadores no codiciosos (lazy) con ?
html = "<tag>contenido</tag><tag>otro</tag>"
print(f"\nCodicioso '<.*>': {re.findall(r'<.*>', html)}")
print(f"No codicioso '<.*?>': {re.findall(r'<.*?>', html)}")

# ========================================
# ANCLAS
# ========================================

print("\n=== ANCLAS ===\n")

texto = "Python es genial"

# ^ - Inicio de string (o línea con MULTILINE)
print(f"'^Python': {re.search(r'^Python', texto)}")
print(f"'^genial': {re.search(r'^genial', texto)}")  # None

# $ - Final de string (o línea con MULTILINE)
print(f"'genial$': {re.search(r'genial$', texto)}")
print(f"'Python$': {re.search(r'Python$', texto)}")  # None

# \b - Límite de palabra
texto = "cat category caterpillar"
print(f"'\\bcat\\b': {re.findall(r'\bcat\b', texto)}")  # Solo 'cat'
print(f"'cat': {re.findall(r'cat', texto)}")  # Todos

# ========================================
# CLASES DE CARACTERES
# ========================================

print("\n=== CLASES DE CARACTERES ===\n")

texto = "abc123XYZ!@#"

# [abc] - Cualquiera de estos caracteres
print(f"'[aeiou]': {re.findall(r'[aeiou]', texto)}")

# [a-z] - Rango
print(f"'[a-z]': {re.findall(r'[a-z]', texto)}")
print(f"'[A-Z]': {re.findall(r'[A-Z]', texto)}")
print(f"'[0-9]': {re.findall(r'[0-9]', texto)}")

# [^abc] - Negación (cualquiera EXCEPTO estos)
print(f"'[^a-zA-Z]': {re.findall(r'[^a-zA-Z]', texto)}")

# Combinaciones
print(f"'[a-zA-Z0-9]': {re.findall(r'[a-zA-Z0-9]', texto)}")

# ========================================
# ALTERNANCIA Y AGRUPACIÓN
# ========================================

print("\n=== ALTERNANCIA Y AGRUPACIÓN ===\n")

texto = "Error: fallo en conexión. Warning: timeout. Info: OK"

# | - Alternancia (OR)
print(f"'Error|Warning': {re.findall(r'Error|Warning', texto)}")

# () - Grupos
# Sin grupos, findall retorna toda la coincidencia
print(f"'(Error|Warning):': {re.findall(r'(Error|Warning):', texto)}")

# Con grupos, findall retorna solo los grupos
log = "192.168.1.1 - GET /index.html - 200"
patron = r'(\d+\.\d+\.\d+\.\d+) - (\w+) (.*?) - (\d+)'
match = re.search(patron, log)
if match:
    print(f"\nMatch completo: {match.group(0)}")
    print(f"Grupo 1 (IP): {match.group(1)}")
    print(f"Grupo 2 (Método): {match.group(2)}")
    print(f"Grupo 3 (Ruta): {match.group(3)}")
    print(f"Grupo 4 (Código): {match.group(4)}")
    print(f"Todos los grupos: {match.groups()}")</code></pre>

        <h2>2.3 Patrones Comunes en Ciberseguridad</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Patrones regex comunes en ciberseguridad
"""

import re

# ========================================
# PATRONES COMUNES
# ========================================

patrones = {
    # Direcciones IP (IPv4)
    "ipv4": r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b',
    
    # IP simple (menos estricta)
    "ipv4_simple": r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b',
    
    # Direcciones IPv6 (simplificada)
    "ipv6": r'(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}',
    
    # Email
    "email": r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
    
    # URL
    "url": r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[/\w\-.?&=%]*',
    
    # Dominio
    "dominio": r'\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}\b',
    
    # Dirección MAC
    "mac": r'(?:[0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}',
    
    # Hash MD5
    "md5": r'\b[a-fA-F0-9]{32}\b',
    
    # Hash SHA256
    "sha256": r'\b[a-fA-F0-9]{64}\b',
    
    # Puerto
    "puerto": r'\b(?:[1-9]\d{0,3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])\b',
    
    # CVE
    "cve": r'CVE-\d{4}-\d{4,}',
    
    # Base64
    "base64": r'(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?',
    
    # JWT Token
    "jwt": r'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*',
}

# Compilar patrones
patrones_compilados = {nombre: re.compile(patron) for nombre, patron in patrones.items()}


def extraer_indicadores(texto):
    """
    Extrae indicadores de compromiso (IoC) de un texto.
    """
    resultados = {}
    
    for nombre, patron in patrones_compilados.items():
        matches = patron.findall(texto)
        if matches:
            resultados[nombre] = list(set(matches))  # Eliminar duplicados
    
    return resultados


# ========================================
# PRUEBA
# ========================================

texto_prueba = """
Reporte de incidente de seguridad

El atacante utilizó la IP 192.168.1.100 para realizar el ataque inicial.
También se detectaron conexiones desde 10.0.0.50 y 203.0.113.42.

Se encontraron los siguientes emails en los logs:
- admin@empresa.com
- hacker@malicious-domain.net
- soporte@empresa.com

URLs maliciosas detectadas:
- https://malware.bad-site.com/payload.exe
- http://phishing.example.com/login.php

Hashes de archivos sospechosos:
- MD5: 098f6bcd4621d373cade4e832627b4f6
- SHA256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

Vulnerabilidades explotadas:
- CVE-2024-1234
- CVE-2023-9999

Direcciones MAC de dispositivos comprometidos:
- 00:1A:2B:3C:4D:5E
- AA:BB:CC:DD:EE:FF
"""

print("=== EXTRACCIÓN DE INDICADORES DE COMPROMISO ===\n")

iocs = extraer_indicadores(texto_prueba)

for tipo, valores in iocs.items():
    if valores:
        print(f"[+] {tipo.upper()}:")
        for valor in valores[:5]:  # Limitar a 5 por tipo
            print(f"    - {valor}")
        if len(valores) > 5:
            print(f"    ... y {len(valores) - 5} más")
        print()</code></pre>

        <h2>2.4 Práctica: Extractor de IoCs</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Práctica: Extractor de IPs, emails y URLs de un archivo de texto
"""

import re
import json
from collections import Counter

# Crear archivo de prueba
contenido_log = """
=== LOG DE SEGURIDAD - 2024-01-15 ===

[10:00:01] Conexión entrante desde 192.168.1.100 (puerto 443)
[10:00:02] Autenticación fallida para user@empresa.com desde 10.0.0.50
[10:00:03] Intento de acceso a https://internal.empresa.com/admin
[10:00:04] Email enviado a admin@empresa.com desde external@gmail.com
[10:00:05] Descarga detectada: http://malware.bad-site.com/payload.exe
[10:00:06] Conexión SSH desde 203.0.113.100 - usuario root
[10:00:07] Request a https://api.empresa.com/v1/users
[10:00:08] IP bloqueada: 185.220.101.1 (Tor exit node)
[10:00:09] Alerta: 192.168.1.100 intentando acceso a /etc/passwd
[10:00:10] Email sospechoso de phishing@scam-site.net
[10:00:11] URL maliciosa detectada: https://phishing.fake-bank.com/login
[10:00:12] Conexión desde 192.168.1.100 (múltiples intentos)
[10:00:13] Notificación enviada a security-team@empresa.com
[10:00:14] Acceso denegado para guest@temporal.org
[10:00:15] Download blocked: http://malware.bad-site.com/trojan.zip
"""

with open("security_log.txt", "w") as f:
    f.write(contenido_log)


class ExtractorIoC:
    """Extractor de Indicadores de Compromiso."""
    
    def __init__(self):
        self.patrones = {
            "ip": re.compile(r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'),
            "email": re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'),
            "url": re.compile(r'https?://[^\s<>"{}|\\^`\[\]]+'),
            "dominio": re.compile(r'\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}\b'),
        }
        
        self.resultados = {}
    
    def extraer_de_archivo(self, ruta):
        """Extrae IoCs de un archivo."""
        with open(ruta, "r", encoding="utf-8") as f:
            contenido = f.read()
        
        return self.extraer_de_texto(contenido)
    
    def extraer_de_texto(self, texto):
        """Extrae IoCs de un texto."""
        self.resultados = {}
        
        for tipo, patron in self.patrones.items():
            matches = patron.findall(texto)
            if matches:
                self.resultados[tipo] = {
                    "valores": list(set(matches)),
                    "conteo": Counter(matches),
                    "total": len(matches),
                    "unicos": len(set(matches))
                }
        
        return self.resultados
    
    def clasificar_ips(self):
        """Clasifica las IPs encontradas."""
        if "ip" not in self.resultados:
            return {}
        
        clasificacion = {
            "privadas": [],
            "publicas": [],
            "localhost": [],
            "sospechosas": []
        }
        
        # IPs conocidas como maliciosas (ejemplo)
        ips_maliciosas = {"185.220.101.1", "203.0.113.100"}
        
        for ip in self.resultados["ip"]["valores"]:
            if ip.startswith("127."):
                clasificacion["localhost"].append(ip)
            elif ip.startswith(("10.", "172.16.", "172.17.", "172.18.", 
                               "172.19.", "172.20.", "172.21.", "172.22.",
                               "172.23.", "172.24.", "172.25.", "172.26.",
                               "172.27.", "172.28.", "172.29.", "172.30.",
                               "172.31.", "192.168.")):
                clasificacion["privadas"].append(ip)
            elif ip in ips_maliciosas:
                clasificacion["sospechosas"].append(ip)
            else:
                clasificacion["publicas"].append(ip)
        
        return clasificacion
    
    def clasificar_dominios(self):
        """Clasifica los dominios/URLs encontrados."""
        if "url" not in self.resultados:
            return {}
        
        clasificacion = {
            "internos": [],
            "externos": [],
            "sospechosos": []
        }
        
        palabras_sospechosas = ["malware", "phishing", "bad-site", "scam", "fake"]
        dominios_internos = ["empresa.com", "internal.empresa.com"]
        
        for url in self.resultados["url"]["valores"]:
            es_sospechoso = any(palabra in url.lower() for palabra in palabras_sospechosas)
            es_interno = any(dominio in url for dominio in dominios_internos)
            
            if es_sospechoso:
                clasificacion["sospechosos"].append(url)
            elif es_interno:
                clasificacion["internos"].append(url)
            else:
                clasificacion["externos"].append(url)
        
        return clasificacion
    
    def generar_reporte(self, ruta_salida=None):
        """Genera un reporte de los IoCs encontrados."""
        reporte = []
        reporte.append("=" * 60)
        reporte.append("   REPORTE DE INDICADORES DE COMPROMISO (IoC)")
        reporte.append("=" * 60)
        
        # Resumen
        reporte.append("\n[*] RESUMEN:")
        for tipo, datos in self.resultados.items():
            reporte.append(f"    {tipo.upper()}: {datos['unicos']} únicos ({datos['total']} total)")
        
        # IPs
        if "ip" in self.resultados:
            reporte.append("\n[*] DIRECCIONES IP:")
            clasificacion = self.clasificar_ips()
            
            if clasificacion["sospechosas"]:
                reporte.append("    ⚠ SOSPECHOSAS:")
                for ip in clasificacion["sospechosas"]:
                    count = self.resultados["ip"]["conteo"][ip]
                    reporte.append(f"      - {ip} ({count} ocurrencias)")
            
            if clasificacion["publicas"]:
                reporte.append("    Públicas:")
                for ip in clasificacion["publicas"]:
                    reporte.append(f"      - {ip}")
            
            if clasificacion["privadas"]:
                reporte.append("    Privadas:")
                for ip in clasificacion["privadas"][:5]:
                    count = self.resultados["ip"]["conteo"][ip]
                    reporte.append(f"      - {ip} ({count} ocurrencias)")
        
        # URLs
        if "url" in self.resultados:
            reporte.append("\n[*] URLs:")
            clasificacion = self.clasificar_dominios()
            
            if clasificacion["sospechosos"]:
                reporte.append("    ⚠ SOSPECHOSAS:")
                for url in clasificacion["sospechosos"]:
                    reporte.append(f"      - {url}")
            
            if clasificacion["externos"]:
                reporte.append("    Externos:")
                for url in clasificacion["externos"]:
                    reporte.append(f"      - {url}")
        
        # Emails
        if "email" in self.resultados:
            reporte.append("\n[*] EMAILS:")
            for email in self.resultados["email"]["valores"]:
                reporte.append(f"    - {email}")
        
        reporte.append("\n" + "=" * 60)
        
        texto_reporte = "\n".join(reporte)
        
        if ruta_salida:
            with open(ruta_salida, "w") as f:
                f.write(texto_reporte)
        
        return texto_reporte
    
    def exportar_json(self, ruta):
        """Exporta los resultados en formato JSON."""
        export = {
            "iocs": {},
            "clasificacion": {
                "ips": self.clasificar_ips(),
                "urls": self.clasificar_dominios()
            }
        }
        
        for tipo, datos in self.resultados.items():
            export["iocs"][tipo] = datos["valores"]
        
        with open(ruta, "w") as f:
            json.dump(export, f, indent=4)


# ========================================
# EJECUTAR EXTRACCIÓN
# ========================================

extractor = ExtractorIoC()
extractor.extraer_de_archivo("security_log.txt")

# Mostrar reporte
print(extractor.generar_reporte())

# Exportar a JSON
extractor.exportar_json("iocs_extraidos.json")
print("[+] IoCs exportados a: iocs_extraidos.json")</code></pre>

        <h1>BLOQUE 3: Interacción con el Sistema Operativo</h1>

        <h2>3.1 Módulo os</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo os: navegación de directorios y variables de entorno
"""

import os

# ========================================
# INFORMACIÓN DEL SISTEMA
# ========================================

print("=== INFORMACIÓN DEL SISTEMA ===\n")

print(f"Sistema operativo: {os.name}")  # 'posix' (Linux/Mac) o 'nt' (Windows)
print(f"Separador de rutas: {os.sep}")
print(f"Separador de PATH: {os.pathsep}")
print(f"Salto de línea: {repr(os.linesep)}")

# ========================================
# DIRECTORIO ACTUAL Y NAVEGACIÓN
# ========================================

print("\n=== NAVEGACIÓN DE DIRECTORIOS ===\n")

# Directorio actual
directorio_actual = os.getcwd()
print(f"Directorio actual: {directorio_actual}")

# Listar contenido
print(f"\nContenido del directorio:")
for item in os.listdir('.'):
    tipo = "DIR " if os.path.isdir(item) else "FILE"
    print(f"  [{tipo}] {item}")

# Crear directorio
nuevo_dir = "test_directorio"
if not os.path.exists(nuevo_dir):
    os.mkdir(nuevo_dir)
    print(f"\n[+] Directorio creado: {nuevo_dir}")

# Crear directorios anidados
ruta_anidada = "test_directorio/nivel1/nivel2"
os.makedirs(ruta_anidada, exist_ok=True)  # exist_ok evita error si existe
print(f"[+] Directorios anidados creados: {ruta_anidada}")

# Cambiar directorio (comentado para no afectar el script)
# os.chdir(nuevo_dir)
# print(f"Nuevo directorio actual: {os.getcwd()}")
# os.chdir('..')  # Volver

# ========================================
# RUTAS CON os.path
# ========================================

print("\n=== MANEJO DE RUTAS ===\n")

ruta = "/home/usuario/documentos/archivo.txt"

print(f"Ruta completa: {ruta}")
print(f"Nombre base: {os.path.basename(ruta)}")      # archivo.txt
print(f"Directorio: {os.path.dirname(ruta)}")        # /home/usuario/documentos
print(f"División: {os.path.split(ruta)}")            # Tupla (dir, archivo)
print(f"Extensión: {os.path.splitext(ruta)}")        # Tupla (ruta, .ext)

# Construir rutas de forma portable
ruta_nueva = os.path.join("home", "usuario", "archivo.txt")
print(f"Ruta construida: {ruta_nueva}")

# Ruta absoluta
print(f"Ruta absoluta de '.': {os.path.abspath('.')}")

# Verificaciones
print(f"\n¿Existe '.': {os.path.exists('.')}")
print(f"¿Es archivo 'os.py'?: {os.path.isfile('os.py')}")
print(f"¿Es directorio '.'?: {os.path.isdir('.')}")

# ========================================
# VARIABLES DE ENTORNO
# ========================================

print("\n=== VARIABLES DE ENTORNO ===\n")

# Obtener variable
path = os.environ.get('PATH', 'No definida')
home = os.environ.get('HOME', os.environ.get('USERPROFILE', 'No definida'))
user = os.environ.get('USER', os.environ.get('USERNAME', 'No definido'))

print(f"Usuario: {user}")
print(f"Home: {home}")
print(f"PATH (primeros 100 chars): {path[:100]}...")

# Variables de seguridad interesantes
print("\nVariables potencialmente sensibles:")
vars_sensibles = ['API_KEY', 'SECRET_KEY', 'DATABASE_URL', 'AWS_ACCESS_KEY_ID', 'PASSWORD']
for var in vars_sensibles:
    valor = os.environ.get(var)
    if valor:
        print(f"  ⚠ {var}: {'*' * min(len(valor), 10)} (encontrada)")
    else:
        print(f"  ✓ {var}: No definida")

# Establecer variable (solo para este proceso)
os.environ['MI_VARIABLE'] = 'valor_secreto'
print(f"\nVariable establecida: {os.environ.get('MI_VARIABLE')}")

# Listar todas las variables
print(f"\nTotal variables de entorno: {len(os.environ)}")

# ========================================
# RECORRER ÁRBOL DE DIRECTORIOS
# ========================================

print("\n=== RECORRER DIRECTORIOS ===\n")

# os.walk() - Recorre recursivamente
print("Estructura de 'test_directorio':")
for raiz, dirs, archivos in os.walk("test_directorio"):
    nivel = raiz.replace("test_directorio", "").count(os.sep)
    indentacion = "  " * nivel
    print(f"{indentacion}{os.path.basename(raiz)}/")
    
    # Mostrar archivos
    subindent = "  " * (nivel + 1)
    for archivo in archivos:
        print(f"{subindent}{archivo}")

# ========================================
# LIMPIEZA
# ========================================

# Eliminar directorio vacío
# os.rmdir("directorio_vacio")

# Eliminar archivo
# os.remove("archivo.txt")

# Eliminar árbol de directorios (usar shutil.rmtree para no vacíos)
import shutil
if os.path.exists("test_directorio"):
    shutil.rmtree("test_directorio")
    print("\n[+] Directorio de prueba eliminado")</code></pre>

        <h2>3.2 Módulo subprocess</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo subprocess: ejecución de comandos del sistema
"""

import subprocess
import sys

# ========================================
# subprocess.run() - FORMA MODERNA
# ========================================

print("=== subprocess.run() ===\n")

# Ejecutar comando simple
resultado = subprocess.run(["echo", "Hola desde subprocess"], capture_output=True, text=True)
print(f"Salida: {resultado.stdout}")
print(f"Código de retorno: {resultado.returncode}")

# En Windows usar shell=True para comandos internos
# resultado = subprocess.run("echo Hola", shell=True, capture_output=True, text=True)

# Comando con argumentos
if sys.platform != "win32":
    resultado = subprocess.run(["ls", "-la"], capture_output=True, text=True)
    print(f"ls -la:\n{resultado.stdout[:500]}...")
else:
    resultado = subprocess.run(["dir"], shell=True, capture_output=True, text=True)
    print(f"dir:\n{resultado.stdout[:500]}...")

# ========================================
# CAPTURAR ERRORES
# ========================================

print("\n=== MANEJO DE ERRORES ===\n")

# Comando que falla
resultado = subprocess.run(
    ["ls", "/directorio_inexistente"],
    capture_output=True,
    text=True
)
print(f"Código de retorno: {resultado.returncode}")
print(f"Error: {resultado.stderr}")

# Lanzar excepción si falla
try:
    resultado = subprocess.run(
        ["ls", "/directorio_inexistente"],
        capture_output=True,
        text=True,
        check=True  # Lanza CalledProcessError si returncode != 0
    )
except subprocess.CalledProcessError as e:
    print(f"Comando falló con código {e.returncode}")
    print(f"Error: {e.stderr}")

# ========================================
# TIMEOUT
# ========================================

print("\n=== TIMEOUT ===\n")

try:
    # Comando que tarda mucho (simulado con sleep)
    resultado = subprocess.run(
        ["sleep", "10"],
        timeout=2,  # Timeout de 2 segundos
        capture_output=True
    )
except subprocess.TimeoutExpired:
    print("[!] Comando excedió el tiempo límite")

# ========================================
# COMANDOS DE RED ÚTILES
# ========================================

print("\n=== COMANDOS DE RED ===\n")

def ejecutar_comando(comando, timeout=10):
    """Ejecuta un comando y retorna la salida."""
    try:
        resultado = subprocess.run(
            comando,
            capture_output=True,
            text=True,
            timeout=timeout,
            shell=isinstance(comando, str)
        )
        return resultado.stdout, resultado.stderr, resultado.returncode
    except subprocess.TimeoutExpired:
        return None, "Timeout", -1
    except Exception as e:
        return None, str(e), -1

# Ping (un solo paquete)
if sys.platform != "win32":
    stdout, stderr, code = ejecutar_comando(["ping", "-c", "1", "8.8.8.8"])
else:
    stdout, stderr, code = ejecutar_comando(["ping", "-n", "1", "8.8.8.8"])

if code == 0:
    print("[+] Ping a 8.8.8.8 exitoso")
    # Extraer tiempo
    for linea in stdout.split('\n'):
        if 'time=' in linea or 'tiempo=' in linea:
            print(f"    {linea.strip()}")
            break
else:
    print(f"[-] Ping falló: {stderr}")

# Información de red
if sys.platform != "win32":
    stdout, stderr, code = ejecutar_comando(["ifconfig"])
    if code != 0:
        stdout, stderr, code = ejecutar_comando(["ip", "addr"])
else:
    stdout, stderr, code = ejecutar_comando(["ipconfig"])

if stdout:
    print(f"\n[+] Configuración de red (primeras líneas):")
    for linea in stdout.split('\n')[:10]:
        if linea.strip():
            print(f"    {linea}")

# ========================================
# SHELL INTERACTIVO (CUIDADO)
# ========================================

print("\n=== NOTAS DE SEGURIDAD ===\n")

# NUNCA usar shell=True con entrada de usuario sin sanitizar
entrada_usuario = "8.8.8.8; cat /etc/passwd"  # Inyección de comando

# PELIGROSO:
# subprocess.run(f"ping -c 1 {entrada_usuario}", shell=True)

# SEGURO: usar lista de argumentos
ip_segura = entrada_usuario.split(';')[0].strip()  # Sanitizar
print(f"[!] Siempre sanitizar entrada de usuario")
print(f"    Entrada original: {entrada_usuario}")
print(f"    Entrada sanitizada: {ip_segura}")

# ========================================
# Popen PARA CONTROL AVANZADO
# ========================================

print("\n=== subprocess.Popen() ===\n")

# Para procesos de larga duración o interactivos
proceso = subprocess.Popen(
    ["ping", "-c", "3", "8.8.8.8"] if sys.platform != "win32" else ["ping", "-n", "3", "8.8.8.8"],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True
)

print("Ping en progreso...")

# Leer salida línea por línea en tiempo real
while True:
    linea = proceso.stdout.readline()
    if not linea and proceso.poll() is not None:
        break
    if linea:
        print(f"  {linea.strip()}")

print(f"Proceso terminado con código: {proceso.returncode}")</code></pre>

        <h2>3.3 Módulos platform y shutil</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulos platform y shutil
"""

import platform
import shutil
import os

# ========================================
# MÓDULO PLATFORM
# ========================================

print("=== INFORMACIÓN DEL SISTEMA (platform) ===\n")

print(f"Sistema: {platform.system()}")           # Linux, Windows, Darwin
print(f"Release: {platform.release()}")          # Versión del kernel
print(f"Versión: {platform.version()}")          # Versión detallada
print(f"Máquina: {platform.machine()}")          # Arquitectura (x86_64, arm64)
print(f"Procesador: {platform.processor()}")     # Tipo de procesador
print(f"Plataforma: {platform.platform()}")      # Descripción completa
print(f"Nodo (hostname): {platform.node()}")     # Nombre del equipo

# Información de Python
print(f"\nPython versión: {platform.python_version()}")
print(f"Python implementación: {platform.python_implementation()}")
print(f"Python compilador: {platform.python_compiler()}")

# Tuple con toda la info
print(f"\nuname(): {platform.uname()}")


# Función para generar fingerprint del sistema
def fingerprint_sistema():
    """Genera un fingerprint del sistema para reconocimiento."""
    info = {
        "os": platform.system(),
        "os_release": platform.release(),
        "os_version": platform.version(),
        "hostname": platform.node(),
        "architecture": platform.machine(),
        "processor": platform.processor(),
        "python_version": platform.python_version(),
    }
    
    # Agregar info específica según OS
    if platform.system() == "Linux":
        try:
            with open("/etc/os-release") as f:
                for line in f:
                    if line.startswith("PRETTY_NAME"):
                        info["distro"] = line.split("=")[1].strip().strip('"')
                        break
        except:
            pass
    
    return info


print("\n=== FINGERPRINT DEL SISTEMA ===")
fp = fingerprint_sistema()
for clave, valor in fp.items():
    print(f"  {clave}: {valor}")

# ========================================
# MÓDULO SHUTIL
# ========================================

print("\n=== OPERACIONES CON ARCHIVOS (shutil) ===\n")

# Crear archivos de prueba
os.makedirs("origen", exist_ok=True)
with open("origen/archivo1.txt", "w") as f:
    f.write("Contenido del archivo 1")
with open("origen/archivo2.txt", "w") as f:
    f.write("Contenido del archivo 2")

# Copiar archivo
shutil.copy("origen/archivo1.txt", "origen/archivo1_copia.txt")
print("[+] Archivo copiado con copy()")

# Copiar preservando metadatos
shutil.copy2("origen/archivo1.txt", "origen/archivo1_copia2.txt")
print("[+] Archivo copiado con copy2() (preserva metadatos)")

# Copiar directorio completo
shutil.copytree("origen", "destino")
print("[+] Directorio copiado con copytree()")

# Mover archivo
shutil.move("destino/archivo2.txt", "destino/archivo2_movido.txt")
print("[+] Archivo movido")

# Información de disco
total, usado, libre = shutil.disk_usage("/")
print(f"\n[*] Uso de disco:")
print(f"    Total: {total // (2**30)} GB")
print(f"    Usado: {usado // (2**30)} GB")
print(f"    Libre: {libre // (2**30)} GB")

# Encontrar ejecutables
python_path = shutil.which("python3") or shutil.which("python")
print(f"\n[*] Python encontrado en: {python_path}")

nmap_path = shutil.which("nmap")
print(f"[*] Nmap encontrado en: {nmap_path or 'No instalado'}")

# Limpiar
shutil.rmtree("origen")
shutil.rmtree("destino")
print("\n[+] Directorios de prueba eliminados")</code></pre>

        <h2>3.4 Práctica: Script de Reconocimiento del Sistema</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Práctica: Script de reconocimiento básico del sistema
Recopila información de red, usuarios y procesos
"""

import os
import platform
import subprocess
import json
import socket
from datetime import datetime

def ejecutar_comando(comando, shell=False, timeout=30):
    """Ejecuta un comando y retorna la salida."""
    try:
        if isinstance(comando, str) and not shell:
            comando = comando.split()
        
        resultado = subprocess.run(
            comando,
            capture_output=True,
            text=True,
            timeout=timeout,
            shell=shell
        )
        return resultado.stdout.strip() if resultado.returncode == 0 else None
    except:
        return None


def obtener_info_sistema():
    """Recopila información básica del sistema."""
    return {
        "hostname": platform.node(),
        "sistema_operativo": platform.system(),
        "version_os": platform.release(),
        "version_detallada": platform.version(),
        "arquitectura": platform.machine(),
        "procesador": platform.processor(),
        "python_version": platform.python_version(),
    }


def obtener_info_red():
    """Recopila información de red."""
    info_red = {
        "hostname": socket.gethostname(),
        "interfaces": [],
        "dns_servers": [],
        "gateway": None
    }
    
    # Intentar obtener IP local
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        info_red["ip_local"] = s.getsockname()[0]
        s.close()
    except:
        info_red["ip_local"] = "No disponible"
    
    # Interfaces de red
    if platform.system() == "Linux":
        salida = ejecutar_comando("ip addr")
        if salida:
            lineas = salida.split('\n')
            interfaz_actual = None
            for linea in lineas:
                if ': ' in linea and not linea.startswith(' '):
                    partes = linea.split(': ')
                    if len(partes) >= 2:
                        interfaz_actual = partes[1].split('@')[0]
                elif 'inet ' in linea and interfaz_actual:
                    ip = linea.strip().split()[1]
                    info_red["interfaces"].append({
                        "nombre": interfaz_actual,
                        "ip": ip
                    })
        
        # DNS
        try:
            with open("/etc/resolv.conf") as f:
                for linea in f:
                    if linea.startswith("nameserver"):
                        info_red["dns_servers"].append(linea.split()[1])
        except:
            pass
        
        # Gateway
        salida = ejecutar_comando("ip route")
        if salida:
            for linea in salida.split('\n'):
                if linea.startswith("default"):
                    partes = linea.split()
                    if len(partes) >= 3:
                        info_red["gateway"] = partes[2]
                    break
    
    elif platform.system() == "Windows":
        salida = ejecutar_comando("ipconfig /all", shell=True)
        if salida:
            info_red["raw_output"] = salida[:1000]
    
    return info_red


def obtener_usuarios():
    """Obtiene información de usuarios del sistema."""
    usuarios = {
        "usuario_actual": os.environ.get("USER", os.environ.get("USERNAME", "Desconocido")),
        "home": os.environ.get("HOME", os.environ.get("USERPROFILE", "Desconocido")),
        "shell": os.environ.get("SHELL", "Desconocido"),
        "usuarios_sistema": []
    }
    
    if platform.system() == "Linux":
        try:
            with open("/etc/passwd") as f:
                for linea in f:
                    partes = linea.strip().split(':')
                    if len(partes) >= 7:
                        uid = int(partes[2])
                        # Solo usuarios con UID >= 1000 o root
                        if uid >= 1000 or uid == 0:
                            usuarios["usuarios_sistema"].append({
                                "nombre": partes[0],
                                "uid": uid,
                                "home": partes[5],
                                "shell": partes[6]
                            })
        except:
            pass
        
        # Usuarios logueados
        salida = ejecutar_comando("who")
        if salida:
            usuarios["usuarios_logueados"] = [
                linea.split()[0] for linea in salida.split('\n') if linea
            ]
    
    return usuarios


def obtener_procesos():
    """Obtiene lista de procesos en ejecución."""
    procesos = {
        "total": 0,
        "lista": []
    }
    
    if platform.system() == "Linux":
        salida = ejecutar_comando("ps aux")
        if salida:
            lineas = salida.split('\n')[1:]  # Saltar header
            procesos["total"] = len(lineas)
            
            # Procesos más relevantes (por uso de CPU/memoria)
            for linea in lineas[:20]:
                partes = linea.split(None, 10)
                if len(partes) >= 11:
                    procesos["lista"].append({
                        "usuario": partes[0],
                        "pid": partes[1],
                        "cpu": partes[2],
                        "memoria": partes[3],
                        "comando": partes[10][:50]
                    })
    
    elif platform.system() == "Windows":
        salida = ejecutar_comando("tasklist", shell=True)
        if salida:
            lineas = salida.split('\n')[3:]
            procesos["total"] = len([l for l in lineas if l.strip()])
    
    return procesos


def obtener_puertos_abiertos():
    """Obtiene puertos abiertos/escuchando."""
    puertos = []
    
    if platform.system() == "Linux":
        salida = ejecutar_comando("ss -tuln")
        if salida:
            for linea in salida.split('\n')[1:]:
                partes = linea.split()
                if len(partes) >= 5:
                    estado = partes[1] if len(partes) > 1 else "UNKNOWN"
                    direccion = partes[4] if len(partes) > 4 else ""
                    if "LISTEN" in linea or estado == "UNCONN":
                        puertos.append({
                            "protocolo": partes[0],
                            "direccion": direccion,
                            "estado": estado
                        })
    
    elif platform.system() == "Windows":
        salida = ejecutar_comando("netstat -an", shell=True)
        if salida:
            for linea in salida.split('\n'):
                if "LISTENING" in linea or "ESTABLISHED" in linea:
                    partes = linea.split()
                    if len(partes) >= 4:
                        puertos.append({
                            "protocolo": partes[0],
                            "local": partes[1],
                            "estado": partes[3] if len(partes) > 3 else ""
                        })
    
    return puertos[:20]  # Limitar a 20


def verificar_herramientas():
    """Verifica qué herramientas de seguridad están instaladas."""
    import shutil
    
    herramientas = [
        "nmap", "nikto", "dirb", "gobuster", "hydra",
        "john", "hashcat", "sqlmap", "metasploit",
        "wireshark", "tcpdump", "netcat", "nc",
        "curl", "wget", "ssh", "openssl"
    ]
    
    instaladas = {}
    for herramienta in herramientas:
        ruta = shutil.which(herramienta)
        instaladas[herramienta] = ruta if ruta else False
    
    return instaladas


def generar_reporte():
    """Genera el reporte completo de reconocimiento."""
    print("=" * 60)
    print("   REPORTE DE RECONOCIMIENTO DEL SISTEMA")
    print(f"   Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)
    
    # Sistema
    print("\n[*] INFORMACIÓN DEL SISTEMA:")
    sistema = obtener_info_sistema()
    for clave, valor in sistema.items():
        print(f"    {clave}: {valor}")
    
    # Red
    print("\n[*] INFORMACIÓN DE RED:")
    red = obtener_info_red()
    print(f"    IP Local: {red.get('ip_local', 'N/A')}")
    print(f"    Gateway: {red.get('gateway', 'N/A')}")
    print(f"    DNS: {', '.join(red.get('dns_servers', [])) or 'N/A'}")
    
    if red.get("interfaces"):
        print("    Interfaces:")
        for iface in red["interfaces"]:
            print(f"      - {iface['nombre']}: {iface['ip']}")
    
    # Usuarios
    print("\n[*] USUARIOS:")
    usuarios = obtener_usuarios()
    print(f"    Usuario actual: {usuarios['usuario_actual']}")
    print(f"    Home: {usuarios['home']}")
    print(f"    Shell: {usuarios['shell']}")
    
    if usuarios.get("usuarios_logueados"):
        print(f"    Usuarios logueados: {', '.join(usuarios['usuarios_logueados'])}")
    
    # Procesos
    print("\n[*] PROCESOS:")
    procesos = obtener_procesos()
    print(f"    Total procesos: {procesos['total']}")
    
    # Puertos
    print("\n[*] PUERTOS EN ESCUCHA:")
    puertos = obtener_puertos_abiertos()
    for puerto in puertos[:10]:
        print(f"    {puerto.get('protocolo', 'N/A')}: {puerto.get('direccion', puerto.get('local', 'N/A'))}")
    
    # Herramientas
    print("\n[*] HERRAMIENTAS DE SEGURIDAD:")
    herramientas = verificar_herramientas()
    instaladas = [h for h, r in herramientas.items() if r]
    no_instaladas = [h for h, r in herramientas.items() if not r]
    
    print(f"    Instaladas: {', '.join(instaladas) if instaladas else 'Ninguna'}")
    print(f"    No encontradas: {', '.join(no_instaladas[:5])}...")
    
    print("\n" + "=" * 60)
    
    # Exportar a JSON
    reporte = {
        "fecha": datetime.now().isoformat(),
        "sistema": sistema,
        "red": red,
        "usuarios": usuarios,
        "procesos": procesos,
        "puertos": puertos,
        "herramientas": herramientas
    }
    
    with open("reporte_sistema.json", "w") as f:
        json.dump(reporte, f, indent=4, default=str)
    
    print("[+] Reporte exportado a: reporte_sistema.json")
    
    return reporte


# ========================================
# EJECUTAR
# ========================================

if __name__ == "__main__":
    reporte = generar_reporte()</code></pre>

        <h2>Ejercicios para Practicar</h2>

        <ol>
            <li><strong>Analizador de logs Apache/Nginx</strong>: Parsear logs de acceso web, extraer IPs, URLs, códigos de respuesta y detectar patrones sospechosos.</li>
            <li><strong>Buscador de archivos sensibles</strong>: Crear un script que recorra directorios buscando archivos con extensiones sensibles (.key, .pem, .env, .conf).</li>
            <li><strong>Extractor de metadatos</strong>: Leer archivos y extraer información como fechas de modificación, permisos, tamaño.</li>
            <li><strong>Validador de configuraciones</strong>: Leer archivos de configuración (SSH, Apache) y verificar opciones de seguridad.</li>
            <li><strong>Monitor de procesos</strong>: Script que monitorea procesos nuevos y genera alertas si detecta nombres sospechosos.</li>
        </ol>

    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>