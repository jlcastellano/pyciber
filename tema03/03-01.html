<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SESIÓN 3: Archivos, Expresiones Regulares y OS</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>SESIÓN 3: Archivos, Expresiones Regulares y OS</div>
    </header>

    <section class="contenido-didactico">
        <h1>BLOQUE 1: Manejo de Archivos</h1>

        <h2>1.1 Fundamentos de Lectura y Escritura</h2>
        
        <p>El manejo de archivos es fundamental en ciberseguridad: logs, configuraciones, wordlists, resultados de escaneos, y más.</p>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Fundamentos de manejo de archivos
"""

# ========================================
# ABRIR ARCHIVOS - MODOS BÁSICOS
# ========================================

# Modos de apertura:
# 'r'  - Lectura (default). Error si no existe.
# 'w'  - Escritura. Crea archivo o SOBRESCRIBE si existe.
# 'a'  - Append. Crea archivo o agrega al final si existe.
# 'x'  - Creación exclusiva. Error si ya existe.
# 'r+' - Lectura y escritura.
# 'b'  - Modo binario (agregar a otros modos: 'rb', 'wb')

# ========================================
# ESCRITURA BÁSICA
# ========================================

# Forma tradicional (NO recomendada)
archivo = open("ejemplo.txt", "w")
archivo.write("Primera línea\n")
archivo.write("Segunda línea\n")
archivo.close()  # ¡IMPORTANTE! Siempre cerrar

# Problema: si hay error antes de close(), el archivo queda abierto
# Solución: usar context manager (with)

# ========================================
# CONTEXT MANAGER (WITH) - FORMA RECOMENDADA
# ========================================

# El archivo se cierra automáticamente al salir del bloque
with open("log_seguridad.txt", "w") as archivo:
    archivo.write("=== LOG DE SEGURIDAD ===\n")
    archivo.write("2024-01-15 10:00:01 - Sistema iniciado\n")
    archivo.write("2024-01-15 10:00:02 - Firewall activo\n")
    archivo.write("2024-01-15 10:00:03 - Monitoreo iniciado\n")

print("[+] Archivo creado: log_seguridad.txt")

# ========================================
# LECTURA DE ARCHIVOS
# ========================================

# read() - Lee todo el contenido como string
with open("log_seguridad.txt", "r") as archivo:
    contenido = archivo.read()
    print("\n--- read() ---")
    print(contenido)

# readline() - Lee una línea a la vez
with open("log_seguridad.txt", "r") as archivo:
    print("--- readline() ---")
    linea1 = archivo.readline()
    linea2 = archivo.readline()
    print(f"Línea 1: {linea1.strip()}")
    print(f"Línea 2: {linea2.strip()}")

# readlines() - Lee todas las líneas como lista
with open("log_seguridad.txt", "r") as archivo:
    lineas = archivo.readlines()
    print("\n--- readlines() ---")
    print(f"Total líneas: {len(lineas)}")
    print(f"Lista: {lineas}")

# Iterar directamente (más eficiente en memoria)
with open("log_seguridad.txt", "r") as archivo:
    print("\n--- Iteración directa ---")
    for numero, linea in enumerate(archivo, 1):
        print(f"{numero}: {linea.strip()}")

# ========================================
# APPEND - AGREGAR AL FINAL
# ========================================

with open("log_seguridad.txt", "a") as archivo:
    archivo.write("2024-01-15 10:00:04 - Nuevo evento agregado\n")
    archivo.write("2024-01-15 10:00:05 - Conexión detectada\n")

print("\n[+] Líneas agregadas al archivo")

# Verificar
with open("log_seguridad.txt", "r") as archivo:
    print("\n--- Contenido actualizado ---")
    print(archivo.read())

# ========================================
# ESCRIBIR MÚLTIPLES LÍNEAS
# ========================================

eventos = [
    "ERROR: Intento de acceso fallido",
    "WARNING: Múltiples conexiones desde 192.168.1.100",
    "INFO: Backup completado",
    "CRITICAL: Posible intrusión detectada"
]

with open("alertas.txt", "w") as archivo:
    # Opción 1: writelines (no agrega saltos de línea)
    archivo.writelines(evento + "\n" for evento in eventos)

# Opción 2: write con join
with open("alertas2.txt", "w") as archivo:
    archivo.write("\n".join(eventos))

# ========================================
# VERIFICAR SI ARCHIVO EXISTE
# ========================================

import os

nombre_archivo = "log_seguridad.txt"

if os.path.exists(nombre_archivo):
    print(f"\n[+] El archivo '{nombre_archivo}' existe")
    print(f"    Tamaño: {os.path.getsize(nombre_archivo)} bytes")
else:
    print(f"[-] El archivo '{nombre_archivo}' no existe")

# Verificar si es archivo o directorio
print(f"    Es archivo: {os.path.isfile(nombre_archivo)}")
print(f"    Es directorio: {os.path.isdir(nombre_archivo)}")</code></pre>

        <h2>1.2 Archivos de Texto y Binarios</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Archivos de texto vs binarios
"""

import os

# ========================================
# ARCHIVOS DE TEXTO
# ========================================

# Especificar encoding (importante para compatibilidad)
with open("texto_utf8.txt", "w", encoding="utf-8") as f:
    f.write("Texto con caracteres especiales: áéíóú ñ €\n")
    f.write("日本語テキスト\n")  # Japonés

with open("texto_utf8.txt", "r", encoding="utf-8") as f:
    print("--- Texto UTF-8 ---")
    print(f.read())

# Error común: encoding incorrecto
try:
    with open("texto_utf8.txt", "r", encoding="ascii") as f:
        contenido = f.read()
except UnicodeDecodeError as e:
    print(f"[!] Error de encoding: {e}")

# ========================================
# ARCHIVOS BINARIOS
# ========================================

# Escribir datos binarios
datos_binarios = bytes([0x48, 0x65, 0x6c, 0x6c, 0x6f])  # "Hello" en bytes

with open("datos.bin", "wb") as f:
    f.write(datos_binarios)
    f.write(b"\x00\x01\x02\x03\x04")  # Bytes adicionales

# Leer datos binarios
with open("datos.bin", "rb") as f:
    contenido = f.read()
    print(f"\n--- Archivo binario ---")
    print(f"Bytes: {contenido}")
    print(f"Hex: {contenido.hex()}")
    print(f"Longitud: {len(contenido)} bytes")

# ========================================
# CASO PRÁCTICO: LEER CABECERA DE ARCHIVO
# ========================================

def identificar_tipo_archivo(ruta):
    """
    Identifica el tipo de archivo por sus magic bytes.
    """
    magic_bytes = {
        b'\x89PNG': 'PNG Image',
        b'\xff\xd8\xff': 'JPEG Image',
        b'GIF8': 'GIF Image',
        b'PK\x03\x04': 'ZIP Archive',
        b'%PDF': 'PDF Document',
        b'\x7fELF': 'ELF Executable',
        b'MZ': 'Windows Executable',
    }
    
    try:
        with open(ruta, 'rb') as f:
            cabecera = f.read(8)
        
        for magic, tipo in magic_bytes.items():
            if cabecera.startswith(magic):
                return tipo
        
        return "Desconocido o texto plano"
    
    except FileNotFoundError:
        return "Archivo no encontrado"
    except PermissionError:
        return "Sin permisos de lectura"

# Crear archivo de prueba simulando PNG
with open("fake_image.png", "wb") as f:
    f.write(b'\x89PNG\r\n\x1a\n')
    f.write(b'\x00' * 100)  # Datos simulados

print(f"\nTipo de archivo: {identificar_tipo_archivo('fake_image.png')}")
print(f"Tipo de datos.bin: {identificar_tipo_archivo('datos.bin')}")

# Limpiar archivos de prueba
for archivo in ["datos.bin", "fake_image.png"]:
    if os.path.exists(archivo):
        os.remove(archivo)</code></pre>

        <h2>1.3 Trabajo con CSV y JSON</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Trabajo con archivos CSV y JSON
"""

import csv
import json
from datetime import datetime

# ========================================
# ARCHIVOS CSV
# ========================================

# Datos de ejemplo: resultados de escaneo
resultados_escaneo = [
    {"ip": "192.168.1.1", "puerto": 22, "estado": "open", "servicio": "SSH"},
    {"ip": "192.168.1.1", "puerto": 80, "estado": "open", "servicio": "HTTP"},
    {"ip": "192.168.1.1", "puerto": 443, "estado": "open", "servicio": "HTTPS"},
    {"ip": "192.168.1.2", "puerto": 22, "estado": "open", "servicio": "SSH"},
    {"ip": "192.168.1.2", "puerto": 3306, "estado": "filtered", "servicio": "MySQL"},
]

# Escribir CSV
with open("escaneo.csv", "w", newline="", encoding="utf-8") as f:
    campos = ["ip", "puerto", "estado", "servicio"]
    writer = csv.DictWriter(f, fieldnames=campos)
    
    writer.writeheader()  # Escribe la fila de encabezados
    writer.writerows(resultados_escaneo)  # Escribe todas las filas

print("[+] Archivo CSV creado: escaneo.csv")

# Leer CSV como diccionarios
print("\n--- Leyendo CSV ---")
with open("escaneo.csv", "r", encoding="utf-8") as f:
    reader = csv.DictReader(f)
    
    for fila in reader:
        print(f"  {fila['ip']}:{fila['puerto']} -> {fila['estado']} ({fila['servicio']})")

# Leer CSV como listas
print("\n--- CSV como listas ---")
with open("escaneo.csv", "r", encoding="utf-8") as f:
    reader = csv.reader(f)
    encabezados = next(reader)  # Primera fila
    print(f"Encabezados: {encabezados}")
    
    for fila in reader:
        print(f"  Fila: {fila}")

# ========================================
# ARCHIVOS JSON
# ========================================

# Datos de ejemplo: informe de vulnerabilidades
informe = {
    "objetivo": "192.168.1.0/24",
    "fecha": datetime.now().isoformat(),
    "analista": "security_team",
    "resumen": {
        "hosts_escaneados": 254,
        "hosts_activos": 15,
        "vulnerabilidades_criticas": 3,
        "vulnerabilidades_altas": 7
    },
    "hosts": [
        {
            "ip": "192.168.1.1",
            "hostname": "router.local",
            "puertos": [22, 80, 443],
            "vulnerabilidades": [
                {"cve": "CVE-2024-0001", "severidad": "alta", "descripcion": "Buffer overflow en SSH"}
            ]
        },
        {
            "ip": "192.168.1.10",
            "hostname": "webserver.local",
            "puertos": [22, 80, 443, 8080],
            "vulnerabilidades": []
        }
    ],
    "configuracion": {
        "timeout": 5,
        "threads": 10,
        "verbose": True
    }
}

# Escribir JSON
with open("informe.json", "w", encoding="utf-8") as f:
    json.dump(informe, f, indent=4, ensure_ascii=False)

print("\n[+] Archivo JSON creado: informe.json")

# Leer JSON
with open("informe.json", "r", encoding="utf-8") as f:
    datos = json.load(f)

print("\n--- Leyendo JSON ---")
print(f"Objetivo: {datos['objetivo']}")
print(f"Fecha: {datos['fecha']}")
print(f"Hosts activos: {datos['resumen']['hosts_activos']}")
print(f"Vulnerabilidades críticas: {datos['resumen']['vulnerabilidades_criticas']}")

print("\nHosts encontrados:")
for host in datos['hosts']:
    vulns = len(host['vulnerabilidades'])
    print(f"  {host['ip']} ({host['hostname']}): {len(host['puertos'])} puertos, {vulns} vulns")

# ========================================
# CONVERSIÓN JSON <-> STRING
# ========================================

# Objeto Python a string JSON
diccionario = {"clave": "valor", "numero": 42}
json_string = json.dumps(diccionario)
print(f"\nPython a JSON string: {json_string}")

# String JSON a objeto Python
json_texto = '{"ip": "10.0.0.1", "estado": "activo"}'
objeto = json.loads(json_texto)
print(f"JSON string a Python: {objeto}")
print(f"Acceso a IP: {objeto['ip']}")

# JSON con formato legible
print("\nJSON formateado:")
print(json.dumps(informe["resumen"], indent=2))</code></pre>

        <h2>1.4 Práctica: Parser de Logs de Acceso</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Práctica: Parser de logs de autenticación (auth.log simulado)
"""

from datetime import datetime
from collections import Counter
import json

# Crear archivo de log simulado
logs_auth = """Jan 15 10:00:01 servidor sshd[1234]: Accepted password for admin from 192.168.1.100 port 52341 ssh2
Jan 15 10:00:15 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:00:16 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:00:17 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:00:18 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:00:19 servidor sshd[1235]: Failed password for root from 10.0.0.50 port 43210 ssh2
Jan 15 10:01:00 servidor sshd[1236]: Accepted publickey for developer from 192.168.1.50 port 33421 ssh2
Jan 15 10:02:30 servidor sshd[1237]: Failed password for invalid user test from 203.0.113.100 port 12345 ssh2
Jan 15 10:02:31 servidor sshd[1237]: Failed password for invalid user admin from 203.0.113.100 port 12346 ssh2
Jan 15 10:02:32 servidor sshd[1237]: Failed password for invalid user guest from 203.0.113.100 port 12347 ssh2
Jan 15 10:05:00 servidor sshd[1238]: Accepted password for backup from 192.168.1.200 port 45678 ssh2
Jan 15 10:10:00 servidor sudo[1240]: admin : TTY=pts/0 ; PWD=/home/admin ; USER=root ; COMMAND=/bin/cat /etc/shadow
Jan 15 10:15:00 servidor sshd[1241]: Failed password for root from 10.0.0.50 port 43220 ssh2
Jan 15 10:15:01 servidor sshd[1241]: Failed password for root from 10.0.0.50 port 43220 ssh2
Jan 15 10:20:00 servidor sshd[1242]: Accepted password for webmaster from 192.168.1.75 port 54321 ssh2"""

# Guardar log simulado
with open("auth.log", "w") as f:
    f.write(logs_auth)


def parsear_log_ssh(linea):
    """
    Parsea una línea de log SSH y extrae información relevante.
    
    Returns:
        dict o None si no es una línea de SSH
    """
    if "sshd" not in linea:
        return None
    
    resultado = {
        "timestamp": None,
        "tipo": None,
        "usuario": None,
        "ip": None,
        "puerto": None,
        "metodo": None
    }
    
    # Extraer timestamp (formato simplificado)
    partes = linea.split()
    if len(partes) >= 3:
        resultado["timestamp"] = f"{partes[0]} {partes[1]} {partes[2]}"
    
    # Determinar tipo de evento
    if "Accepted" in linea:
        resultado["tipo"] = "exitoso"
        
        # Extraer método de autenticación
        if "password" in linea:
            resultado["metodo"] = "password"
        elif "publickey" in linea:
            resultado["metodo"] = "publickey"
        
        # Extraer usuario e IP
        try:
            if "for" in linea and "from" in linea:
                idx_for = linea.index("for") + 4
                idx_from = linea.index("from")
                resultado["usuario"] = linea[idx_for:idx_from].strip()
                
                # Extraer IP y puerto
                resto = linea[idx_from + 5:].split()
                resultado["ip"] = resto[0]
                if "port" in linea:
                    idx_port = resto.index("port")
                    resultado["puerto"] = int(resto[idx_port + 1])
        except (ValueError, IndexError):
            pass
            
    elif "Failed" in linea:
        resultado["tipo"] = "fallido"
        resultado["metodo"] = "password"
        
        # Verificar si es usuario inválido
        if "invalid user" in linea:
            resultado["usuario_invalido"] = True
            try:
                idx = linea.index("invalid user") + 13
                resto = linea[idx:].split()
                resultado["usuario"] = resto[0]
                idx_from = resto.index("from")
                resultado["ip"] = resto[idx_from + 1]
            except (ValueError, IndexError):
                pass
        else:
            resultado["usuario_invalido"] = False
            try:
                idx_for = linea.index("for") + 4
                idx_from = linea.index("from")
                resultado["usuario"] = linea[idx_for:idx_from].strip()
                resto = linea[idx_from + 5:].split()
                resultado["ip"] = resto[0]
            except (ValueError, IndexError):
                pass
    
    return resultado


def analizar_logs(ruta_archivo):
    """
    Analiza un archivo de logs y genera estadísticas.
    """
    estadisticas = {
        "total_eventos": 0,
        "logins_exitosos": 0,
        "logins_fallidos": 0,
        "ips_con_fallos": Counter(),
        "usuarios_atacados": Counter(),
        "usuarios_exitosos": [],
        "posibles_ataques": []
    }
    
    with open(ruta_archivo, "r") as f:
        for linea in f:
            resultado = parsear_log_ssh(linea.strip())
            
            if resultado is None:
                continue
            
            estadisticas["total_eventos"] += 1
            
            if resultado["tipo"] == "exitoso":
                estadisticas["logins_exitosos"] += 1
                estadisticas["usuarios_exitosos"].append({
                    "usuario": resultado["usuario"],
                    "ip": resultado["ip"],
                    "metodo": resultado["metodo"],
                    "timestamp": resultado["timestamp"]
                })
            
            elif resultado["tipo"] == "fallido":
                estadisticas["logins_fallidos"] += 1
                if resultado["ip"]:
                    estadisticas["ips_con_fallos"][resultado["ip"]] += 1
                if resultado["usuario"]:
                    estadisticas["usuarios_atacados"][resultado["usuario"]] += 1
    
    # Detectar posibles ataques de fuerza bruta (más de 3 fallos desde misma IP)
    for ip, count in estadisticas["ips_con_fallos"].items():
        if count >= 3:
            estadisticas["posibles_ataques"].append({
                "ip": ip,
                "intentos_fallidos": count,
                "tipo": "Posible fuerza bruta"
            })
    
    return estadisticas


def generar_informe(estadisticas, ruta_salida="informe_auth.json"):
    """
    Genera un informe en formato JSON.
    """
    # Convertir Counters a diccionarios para JSON
    informe = {
        "fecha_analisis": datetime.now().isoformat(),
        "resumen": {
            "total_eventos_ssh": estadisticas["total_eventos"],
            "logins_exitosos": estadisticas["logins_exitosos"],
            "logins_fallidos": estadisticas["logins_fallidos"],
            "tasa_exito": round(
                estadisticas["logins_exitosos"] / max(estadisticas["total_eventos"], 1) * 100, 2
            )
        },
        "logins_exitosos": estadisticas["usuarios_exitosos"],
        "top_ips_fallidas": dict(estadisticas["ips_con_fallos"].most_common(10)),
        "top_usuarios_atacados": dict(estadisticas["usuarios_atacados"].most_common(10)),
        "alertas": estadisticas["posibles_ataques"]
    }
    
    with open(ruta_salida, "w", encoding="utf-8") as f:
        json.dump(informe, f, indent=4, ensure_ascii=False)
    
    return informe


# ========================================
# EJECUTAR ANÁLISIS
# ========================================

print("=" * 60)
print("   ANALIZADOR DE LOGS DE AUTENTICACIÓN")
print("=" * 60)

# Analizar logs
stats = analizar_logs("auth.log")

# Mostrar resultados
print(f"\n[*] RESUMEN DE EVENTOS SSH:")
print(f"    Total eventos: {stats['total_eventos']}")
print(f"    Logins exitosos: {stats['logins_exitosos']}")
print(f"    Logins fallidos: {stats['logins_fallidos']}")

print(f"\n[*] TOP IPs CON INTENTOS FALLIDOS:")
for ip, count in stats["ips_con_fallos"].most_common(5):
    print(f"    {ip}: {count} intentos")

print(f"\n[*] USUARIOS MÁS ATACADOS:")
for usuario, count in stats["usuarios_atacados"].most_common(5):
    print(f"    {usuario}: {count} intentos")

print(f"\n[*] LOGINS EXITOSOS:")
for login in stats["usuarios_exitosos"]:
    print(f"    {login['usuario']} desde {login['ip']} ({login['metodo']})")

if stats["posibles_ataques"]:
    print(f"\n[!] ALERTAS DE SEGURIDAD:")
    for alerta in stats["posibles_ataques"]:
        print(f"    ⚠ {alerta['tipo']}: {alerta['ip']} ({alerta['intentos_fallidos']} intentos)")

# Generar informe JSON
informe = generar_informe(stats)
print(f"\n[+] Informe generado: informe_auth.json")

print("\n" + "=" * 60)</code></pre>

    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>