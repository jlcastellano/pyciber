<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SESIÓN 3: Archivos, Expresiones Regulares y OS</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>SESIÓN 3: Archivos, Expresiones Regulares y OS</div>
    </header>

    <section class="contenido-didactico">
 
        <h1>BLOQUE 3: Interacción con el Sistema Operativo</h1>

        <h2>3.1 Módulo os</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo os: navegación de directorios y variables de entorno
"""

import os

# ========================================
# INFORMACIÓN DEL SISTEMA
# ========================================

print("=== INFORMACIÓN DEL SISTEMA ===\n")

print(f"Sistema operativo: {os.name}")  # 'posix' (Linux/Mac) o 'nt' (Windows)
print(f"Separador de rutas: {os.sep}")
print(f"Separador de PATH: {os.pathsep}")
print(f"Salto de línea: {repr(os.linesep)}")

# ========================================
# DIRECTORIO ACTUAL Y NAVEGACIÓN
# ========================================

print("\n=== NAVEGACIÓN DE DIRECTORIOS ===\n")

# Directorio actual
directorio_actual = os.getcwd()
print(f"Directorio actual: {directorio_actual}")

# Listar contenido
print(f"\nContenido del directorio:")
for item in os.listdir('.'):
    tipo = "DIR " if os.path.isdir(item) else "FILE"
    print(f"  [{tipo}] {item}")

# Crear directorio
nuevo_dir = "test_directorio"
if not os.path.exists(nuevo_dir):
    os.mkdir(nuevo_dir)
    print(f"\n[+] Directorio creado: {nuevo_dir}")

# Crear directorios anidados
ruta_anidada = "test_directorio/nivel1/nivel2"
os.makedirs(ruta_anidada, exist_ok=True)  # exist_ok evita error si existe
print(f"[+] Directorios anidados creados: {ruta_anidada}")

# Cambiar directorio (comentado para no afectar el script)
# os.chdir(nuevo_dir)
# print(f"Nuevo directorio actual: {os.getcwd()}")
# os.chdir('..')  # Volver

# ========================================
# RUTAS CON os.path
# ========================================

print("\n=== MANEJO DE RUTAS ===\n")

ruta = "/home/usuario/documentos/archivo.txt"

print(f"Ruta completa: {ruta}")
print(f"Nombre base: {os.path.basename(ruta)}")      # archivo.txt
print(f"Directorio: {os.path.dirname(ruta)}")        # /home/usuario/documentos
print(f"División: {os.path.split(ruta)}")            # Tupla (dir, archivo)
print(f"Extensión: {os.path.splitext(ruta)}")        # Tupla (ruta, .ext)

# Construir rutas de forma portable
ruta_nueva = os.path.join("home", "usuario", "archivo.txt")
print(f"Ruta construida: {ruta_nueva}")

# Ruta absoluta
print(f"Ruta absoluta de '.': {os.path.abspath('.')}")

# Verificaciones
print(f"\n¿Existe '.': {os.path.exists('.')}")
print(f"¿Es archivo 'os.py'?: {os.path.isfile('os.py')}")
print(f"¿Es directorio '.'?: {os.path.isdir('.')}")

# ========================================
# VARIABLES DE ENTORNO
# ========================================

print("\n=== VARIABLES DE ENTORNO ===\n")

# Obtener variable
path = os.environ.get('PATH', 'No definida')
home = os.environ.get('HOME', os.environ.get('USERPROFILE', 'No definida'))
user = os.environ.get('USER', os.environ.get('USERNAME', 'No definido'))

print(f"Usuario: {user}")
print(f"Home: {home}")
print(f"PATH (primeros 100 chars): {path[:100]}...")

# Variables de seguridad interesantes
print("\nVariables potencialmente sensibles:")
vars_sensibles = ['API_KEY', 'SECRET_KEY', 'DATABASE_URL', 'AWS_ACCESS_KEY_ID', 'PASSWORD']
for var in vars_sensibles:
    valor = os.environ.get(var)
    if valor:
        print(f"  ⚠ {var}: {'*' * min(len(valor), 10)} (encontrada)")
    else:
        print(f"  ✓ {var}: No definida")

# Establecer variable (solo para este proceso)
os.environ['MI_VARIABLE'] = 'valor_secreto'
print(f"\nVariable establecida: {os.environ.get('MI_VARIABLE')}")

# Listar todas las variables
print(f"\nTotal variables de entorno: {len(os.environ)}")

# ========================================
# RECORRER ÁRBOL DE DIRECTORIOS
# ========================================

print("\n=== RECORRER DIRECTORIOS ===\n")

# os.walk() - Recorre recursivamente
print("Estructura de 'test_directorio':")
for raiz, dirs, archivos in os.walk("test_directorio"):
    nivel = raiz.replace("test_directorio", "").count(os.sep)
    indentacion = "  " * nivel
    print(f"{indentacion}{os.path.basename(raiz)}/")
    
    # Mostrar archivos
    subindent = "  " * (nivel + 1)
    for archivo in archivos:
        print(f"{subindent}{archivo}")

# ========================================
# LIMPIEZA
# ========================================

# Eliminar directorio vacío
# os.rmdir("directorio_vacio")

# Eliminar archivo
# os.remove("archivo.txt")

# Eliminar árbol de directorios (usar shutil.rmtree para no vacíos)
import shutil
if os.path.exists("test_directorio"):
    shutil.rmtree("test_directorio")
    print("\n[+] Directorio de prueba eliminado")</code></pre>

        <h2>3.2 Módulo subprocess</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo subprocess: ejecución de comandos del sistema
"""

import subprocess
import sys

# ========================================
# subprocess.run() - FORMA MODERNA
# ========================================

print("=== subprocess.run() ===\n")

# Ejecutar comando simple
resultado = subprocess.run(["echo", "Hola desde subprocess"], capture_output=True, text=True)
print(f"Salida: {resultado.stdout}")
print(f"Código de retorno: {resultado.returncode}")

# En Windows usar shell=True para comandos internos
# resultado = subprocess.run("echo Hola", shell=True, capture_output=True, text=True)

# Comando con argumentos
if sys.platform != "win32":
    resultado = subprocess.run(["ls", "-la"], capture_output=True, text=True)
    print(f"ls -la:\n{resultado.stdout[:500]}...")
else:
    resultado = subprocess.run(["dir"], shell=True, capture_output=True, text=True)
    print(f"dir:\n{resultado.stdout[:500]}...")

# ========================================
# CAPTURAR ERRORES
# ========================================

print("\n=== MANEJO DE ERRORES ===\n")

# Comando que falla
resultado = subprocess.run(
    ["ls", "/directorio_inexistente"],
    capture_output=True,
    text=True
)
print(f"Código de retorno: {resultado.returncode}")
print(f"Error: {resultado.stderr}")

# Lanzar excepción si falla
try:
    resultado = subprocess.run(
        ["ls", "/directorio_inexistente"],
        capture_output=True,
        text=True,
        check=True  # Lanza CalledProcessError si returncode != 0
    )
except subprocess.CalledProcessError as e:
    print(f"Comando falló con código {e.returncode}")
    print(f"Error: {e.stderr}")

# ========================================
# TIMEOUT
# ========================================

print("\n=== TIMEOUT ===\n")

try:
    # Comando que tarda mucho (simulado con sleep)
    resultado = subprocess.run(
        ["sleep", "10"],
        timeout=2,  # Timeout de 2 segundos
        capture_output=True
    )
except subprocess.TimeoutExpired:
    print("[!] Comando excedió el tiempo límite")

# ========================================
# COMANDOS DE RED ÚTILES
# ========================================

print("\n=== COMANDOS DE RED ===\n")

def ejecutar_comando(comando, timeout=10):
    """Ejecuta un comando y retorna la salida."""
    try:
        resultado = subprocess.run(
            comando,
            capture_output=True,
            text=True,
            timeout=timeout,
            shell=isinstance(comando, str)
        )
        return resultado.stdout, resultado.stderr, resultado.returncode
    except subprocess.TimeoutExpired:
        return None, "Timeout", -1
    except Exception as e:
        return None, str(e), -1

# Ping (un solo paquete)
if sys.platform != "win32":
    stdout, stderr, code = ejecutar_comando(["ping", "-c", "1", "8.8.8.8"])
else:
    stdout, stderr, code = ejecutar_comando(["ping", "-n", "1", "8.8.8.8"])

if code == 0:
    print("[+] Ping a 8.8.8.8 exitoso")
    # Extraer tiempo
    for linea in stdout.split('\n'):
        if 'time=' in linea or 'tiempo=' in linea:
            print(f"    {linea.strip()}")
            break
else:
    print(f"[-] Ping falló: {stderr}")

# Información de red
if sys.platform != "win32":
    stdout, stderr, code = ejecutar_comando(["ifconfig"])
    if code != 0:
        stdout, stderr, code = ejecutar_comando(["ip", "addr"])
else:
    stdout, stderr, code = ejecutar_comando(["ipconfig"])

if stdout:
    print(f"\n[+] Configuración de red (primeras líneas):")
    for linea in stdout.split('\n')[:10]:
        if linea.strip():
            print(f"    {linea}")

# ========================================
# SHELL INTERACTIVO (CUIDADO)
# ========================================

print("\n=== NOTAS DE SEGURIDAD ===\n")

# NUNCA usar shell=True con entrada de usuario sin sanitizar
entrada_usuario = "8.8.8.8; cat /etc/passwd"  # Inyección de comando

# PELIGROSO:
# subprocess.run(f"ping -c 1 {entrada_usuario}", shell=True)

# SEGURO: usar lista de argumentos
ip_segura = entrada_usuario.split(';')[0].strip()  # Sanitizar
print(f"[!] Siempre sanitizar entrada de usuario")
print(f"    Entrada original: {entrada_usuario}")
print(f"    Entrada sanitizada: {ip_segura}")

# ========================================
# Popen PARA CONTROL AVANZADO
# ========================================

print("\n=== subprocess.Popen() ===\n")

# Para procesos de larga duración o interactivos
proceso = subprocess.Popen(
    ["ping", "-c", "3", "8.8.8.8"] if sys.platform != "win32" else ["ping", "-n", "3", "8.8.8.8"],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True
)

print("Ping en progreso...")

# Leer salida línea por línea en tiempo real
while True:
    linea = proceso.stdout.readline()
    if not linea and proceso.poll() is not None:
        break
    if linea:
        print(f"  {linea.strip()}")

print(f"Proceso terminado con código: {proceso.returncode}")</code></pre>

        <h2>3.3 Módulos platform y shutil</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulos platform y shutil
"""

import platform
import shutil
import os

# ========================================
# MÓDULO PLATFORM
# ========================================

print("=== INFORMACIÓN DEL SISTEMA (platform) ===\n")

print(f"Sistema: {platform.system()}")           # Linux, Windows, Darwin
print(f"Release: {platform.release()}")          # Versión del kernel
print(f"Versión: {platform.version()}")          # Versión detallada
print(f"Máquina: {platform.machine()}")          # Arquitectura (x86_64, arm64)
print(f"Procesador: {platform.processor()}")     # Tipo de procesador
print(f"Plataforma: {platform.platform()}")      # Descripción completa
print(f"Nodo (hostname): {platform.node()}")     # Nombre del equipo

# Información de Python
print(f"\nPython versión: {platform.python_version()}")
print(f"Python implementación: {platform.python_implementation()}")
print(f"Python compilador: {platform.python_compiler()}")

# Tuple con toda la info
print(f"\nuname(): {platform.uname()}")


# Función para generar fingerprint del sistema
def fingerprint_sistema():
    """Genera un fingerprint del sistema para reconocimiento."""
    info = {
        "os": platform.system(),
        "os_release": platform.release(),
        "os_version": platform.version(),
        "hostname": platform.node(),
        "architecture": platform.machine(),
        "processor": platform.processor(),
        "python_version": platform.python_version(),
    }
    
    # Agregar info específica según OS
    if platform.system() == "Linux":
        try:
            with open("/etc/os-release") as f:
                for line in f:
                    if line.startswith("PRETTY_NAME"):
                        info["distro"] = line.split("=")[1].strip().strip('"')
                        break
        except:
            pass
    
    return info


print("\n=== FINGERPRINT DEL SISTEMA ===")
fp = fingerprint_sistema()
for clave, valor in fp.items():
    print(f"  {clave}: {valor}")

# ========================================
# MÓDULO SHUTIL
# ========================================

print("\n=== OPERACIONES CON ARCHIVOS (shutil) ===\n")

# Crear archivos de prueba
os.makedirs("origen", exist_ok=True)
with open("origen/archivo1.txt", "w") as f:
    f.write("Contenido del archivo 1")
with open("origen/archivo2.txt", "w") as f:
    f.write("Contenido del archivo 2")

# Copiar archivo
shutil.copy("origen/archivo1.txt", "origen/archivo1_copia.txt")
print("[+] Archivo copiado con copy()")

# Copiar preservando metadatos
shutil.copy2("origen/archivo1.txt", "origen/archivo1_copia2.txt")
print("[+] Archivo copiado con copy2() (preserva metadatos)")

# Copiar directorio completo
shutil.copytree("origen", "destino")
print("[+] Directorio copiado con copytree()")

# Mover archivo
shutil.move("destino/archivo2.txt", "destino/archivo2_movido.txt")
print("[+] Archivo movido")

# Información de disco
total, usado, libre = shutil.disk_usage("/")
print(f"\n[*] Uso de disco:")
print(f"    Total: {total // (2**30)} GB")
print(f"    Usado: {usado // (2**30)} GB")
print(f"    Libre: {libre // (2**30)} GB")

# Encontrar ejecutables
python_path = shutil.which("python3") or shutil.which("python")
print(f"\n[*] Python encontrado en: {python_path}")

nmap_path = shutil.which("nmap")
print(f"[*] Nmap encontrado en: {nmap_path or 'No instalado'}")

# Limpiar
shutil.rmtree("origen")
shutil.rmtree("destino")
print("\n[+] Directorios de prueba eliminados")</code></pre>


    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>