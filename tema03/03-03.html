<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SESIÓN 3: Archivos, Expresiones Regulares y OS</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>SESIÓN 3: Archivos, Expresiones Regulares y OS</div>
    </header>

    <section class="contenido-didactico">
 
        <h1>BLOQUE 3: Interacción con el Sistema Operativo</h1>

        <h2>3.1 Módulo os</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo os: navegación de directorios y variables de entorno
"""

import os

# ========================================
# INFORMACIÓN DEL SISTEMA
# ========================================

print("=== INFORMACIÓN DEL SISTEMA ===\n")

print(f"Sistema operativo: {os.name}")  # 'posix' (Linux/Mac) o 'nt' (Windows)
print(f"Separador de rutas: {os.sep}")
print(f"Separador de PATH: {os.pathsep}")
print(f"Salto de línea: {repr(os.linesep)}")

# ========================================
# DIRECTORIO ACTUAL Y NAVEGACIÓN
# ========================================

print("\n=== NAVEGACIÓN DE DIRECTORIOS ===\n")

# Directorio actual
directorio_actual = os.getcwd()
print(f"Directorio actual: {directorio_actual}")

# Listar contenido
print(f"\nContenido del directorio:")
for item in os.listdir('.'):
    tipo = "DIR " if os.path.isdir(item) else "FILE"
    print(f"  [{tipo}] {item}")

# Crear directorio
nuevo_dir = "test_directorio"
if not os.path.exists(nuevo_dir):
    os.mkdir(nuevo_dir)
    print(f"\n[+] Directorio creado: {nuevo_dir}")

# Crear directorios anidados
ruta_anidada = "test_directorio/nivel1/nivel2"
os.makedirs(ruta_anidada, exist_ok=True)  # exist_ok evita error si existe
print(f"[+] Directorios anidados creados: {ruta_anidada}")

# Cambiar directorio (comentado para no afectar el script)
# os.chdir(nuevo_dir)
# print(f"Nuevo directorio actual: {os.getcwd()}")
# os.chdir('..')  # Volver

# ========================================
# RUTAS CON os.path
# ========================================

print("\n=== MANEJO DE RUTAS ===\n")

ruta = "/home/usuario/documentos/archivo.txt"

print(f"Ruta completa: {ruta}")
print(f"Nombre base: {os.path.basename(ruta)}")      # archivo.txt
print(f"Directorio: {os.path.dirname(ruta)}")        # /home/usuario/documentos
print(f"División: {os.path.split(ruta)}")            # Tupla (dir, archivo)
print(f"Extensión: {os.path.splitext(ruta)}")        # Tupla (ruta, .ext)

# Construir rutas de forma portable
ruta_nueva = os.path.join("home", "usuario", "archivo.txt")
print(f"Ruta construida: {ruta_nueva}")

# Ruta absoluta
print(f"Ruta absoluta de '.': {os.path.abspath('.')}")

# Verificaciones
print(f"\n¿Existe '.': {os.path.exists('.')}")
print(f"¿Es archivo 'os.py'?: {os.path.isfile('os.py')}")
print(f"¿Es directorio '.'?: {os.path.isdir('.')}")

# ========================================
# VARIABLES DE ENTORNO
# ========================================

print("\n=== VARIABLES DE ENTORNO ===\n")

# Obtener variable
path = os.environ.get('PATH', 'No definida')
home = os.environ.get('HOME', os.environ.get('USERPROFILE', 'No definida'))
user = os.environ.get('USER', os.environ.get('USERNAME', 'No definido'))

print(f"Usuario: {user}")
print(f"Home: {home}")
print(f"PATH (primeros 100 chars): {path[:100]}...")

# Variables de seguridad interesantes
print("\nVariables potencialmente sensibles:")
vars_sensibles = ['API_KEY', 'SECRET_KEY', 'DATABASE_URL', 'AWS_ACCESS_KEY_ID', 'PASSWORD']
for var in vars_sensibles:
    valor = os.environ.get(var)
    if valor:
        print(f"  ⚠ {var}: {'*' * min(len(valor), 10)} (encontrada)")
    else:
        print(f"  ✓ {var}: No definida")

# Establecer variable (solo para este proceso)
os.environ['MI_VARIABLE'] = 'valor_secreto'
print(f"\nVariable establecida: {os.environ.get('MI_VARIABLE')}")

# Listar todas las variables
print(f"\nTotal variables de entorno: {len(os.environ)}")

# ========================================
# RECORRER ÁRBOL DE DIRECTORIOS
# ========================================

print("\n=== RECORRER DIRECTORIOS ===\n")

# os.walk() - Recorre recursivamente
print("Estructura de 'test_directorio':")
for raiz, dirs, archivos in os.walk("test_directorio"):
    nivel = raiz.replace("test_directorio", "").count(os.sep)
    indentacion = "  " * nivel
    print(f"{indentacion}{os.path.basename(raiz)}/")
    
    # Mostrar archivos
    subindent = "  " * (nivel + 1)
    for archivo in archivos:
        print(f"{subindent}{archivo}")

# ========================================
# LIMPIEZA
# ========================================

# Eliminar directorio vacío
# os.rmdir("directorio_vacio")

# Eliminar archivo
# os.remove("archivo.txt")

# Eliminar árbol de directorios (usar shutil.rmtree para no vacíos)
import shutil
if os.path.exists("test_directorio"):
    shutil.rmtree("test_directorio")
    print("\n[+] Directorio de prueba eliminado")</code></pre>

        <h2>3.2 Módulo subprocess</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulo subprocess: ejecución de comandos del sistema
"""

import subprocess
import sys

# ========================================
# subprocess.run() - FORMA MODERNA
# ========================================

print("=== subprocess.run() ===\n")

# Ejecutar comando simple
resultado = subprocess.run(["echo", "Hola desde subprocess"], capture_output=True, text=True)
print(f"Salida: {resultado.stdout}")
print(f"Código de retorno: {resultado.returncode}")

# En Windows usar shell=True para comandos internos
# resultado = subprocess.run("echo Hola", shell=True, capture_output=True, text=True)

# Comando con argumentos
if sys.platform != "win32":
    resultado = subprocess.run(["ls", "-la"], capture_output=True, text=True)
    print(f"ls -la:\n{resultado.stdout[:500]}...")
else:
    resultado = subprocess.run(["dir"], shell=True, capture_output=True, text=True)
    print(f"dir:\n{resultado.stdout[:500]}...")

# ========================================
# CAPTURAR ERRORES
# ========================================

print("\n=== MANEJO DE ERRORES ===\n")

# Comando que falla
resultado = subprocess.run(
    ["ls", "/directorio_inexistente"],
    capture_output=True,
    text=True
)
print(f"Código de retorno: {resultado.returncode}")
print(f"Error: {resultado.stderr}")

# Lanzar excepción si falla
try:
    resultado = subprocess.run(
        ["ls", "/directorio_inexistente"],
        capture_output=True,
        text=True,
        check=True  # Lanza CalledProcessError si returncode != 0
    )
except subprocess.CalledProcessError as e:
    print(f"Comando falló con código {e.returncode}")
    print(f"Error: {e.stderr}")

# ========================================
# TIMEOUT
# ========================================

print("\n=== TIMEOUT ===\n")

try:
    # Comando que tarda mucho (simulado con sleep)
    resultado = subprocess.run(
        ["sleep", "10"],
        timeout=2,  # Timeout de 2 segundos
        capture_output=True
    )
except subprocess.TimeoutExpired:
    print("[!] Comando excedió el tiempo límite")

# ========================================
# COMANDOS DE RED ÚTILES
# ========================================

print("\n=== COMANDOS DE RED ===\n")

def ejecutar_comando(comando, timeout=10):
    """Ejecuta un comando y retorna la salida."""
    try:
        resultado = subprocess.run(
            comando,
            capture_output=True,
            text=True,
            timeout=timeout,
            shell=isinstance(comando, str)
        )
        return resultado.stdout, resultado.stderr, resultado.returncode
    except subprocess.TimeoutExpired:
        return None, "Timeout", -1
    except Exception as e:
        return None, str(e), -1

# Ping (un solo paquete)
if sys.platform != "win32":
    stdout, stderr, code = ejecutar_comando(["ping", "-c", "1", "8.8.8.8"])
else:
    stdout, stderr, code = ejecutar_comando(["ping", "-n", "1", "8.8.8.8"])

if code == 0:
    print("[+] Ping a 8.8.8.8 exitoso")
    # Extraer tiempo
    for linea in stdout.split('\n'):
        if 'time=' in linea or 'tiempo=' in linea:
            print(f"    {linea.strip()}")
            break
else:
    print(f"[-] Ping falló: {stderr}")

# Información de red
if sys.platform != "win32":
    stdout, stderr, code = ejecutar_comando(["ifconfig"])
    if code != 0:
        stdout, stderr, code = ejecutar_comando(["ip", "addr"])
else:
    stdout, stderr, code = ejecutar_comando(["ipconfig"])

if stdout:
    print(f"\n[+] Configuración de red (primeras líneas):")
    for linea in stdout.split('\n')[:10]:
        if linea.strip():
            print(f"    {linea}")

# ========================================
# SHELL INTERACTIVO (CUIDADO)
# ========================================

print("\n=== NOTAS DE SEGURIDAD ===\n")

# NUNCA usar shell=True con entrada de usuario sin sanitizar
entrada_usuario = "8.8.8.8; cat /etc/passwd"  # Inyección de comando

# PELIGROSO:
# subprocess.run(f"ping -c 1 {entrada_usuario}", shell=True)

# SEGURO: usar lista de argumentos
ip_segura = entrada_usuario.split(';')[0].strip()  # Sanitizar
print(f"[!] Siempre sanitizar entrada de usuario")
print(f"    Entrada original: {entrada_usuario}")
print(f"    Entrada sanitizada: {ip_segura}")

# ========================================
# Popen PARA CONTROL AVANZADO
# ========================================

print("\n=== subprocess.Popen() ===\n")

# Para procesos de larga duración o interactivos
proceso = subprocess.Popen(
    ["ping", "-c", "3", "8.8.8.8"] if sys.platform != "win32" else ["ping", "-n", "3", "8.8.8.8"],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True
)

print("Ping en progreso...")

# Leer salida línea por línea en tiempo real
while True:
    linea = proceso.stdout.readline()
    if not linea and proceso.poll() is not None:
        break
    if linea:
        print(f"  {linea.strip()}")

print(f"Proceso terminado con código: {proceso.returncode}")</code></pre>

        <h2>3.3 Módulos platform y shutil</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Módulos platform y shutil
"""

import platform
import shutil
import os

# ========================================
# MÓDULO PLATFORM
# ========================================

print("=== INFORMACIÓN DEL SISTEMA (platform) ===\n")

print(f"Sistema: {platform.system()}")           # Linux, Windows, Darwin
print(f"Release: {platform.release()}")          # Versión del kernel
print(f"Versión: {platform.version()}")          # Versión detallada
print(f"Máquina: {platform.machine()}")          # Arquitectura (x86_64, arm64)
print(f"Procesador: {platform.processor()}")     # Tipo de procesador
print(f"Plataforma: {platform.platform()}")      # Descripción completa
print(f"Nodo (hostname): {platform.node()}")     # Nombre del equipo

# Información de Python
print(f"\nPython versión: {platform.python_version()}")
print(f"Python implementación: {platform.python_implementation()}")
print(f"Python compilador: {platform.python_compiler()}")

# Tuple con toda la info
print(f"\nuname(): {platform.uname()}")


# Función para generar fingerprint del sistema
def fingerprint_sistema():
    """Genera un fingerprint del sistema para reconocimiento."""
    info = {
        "os": platform.system(),
        "os_release": platform.release(),
        "os_version": platform.version(),
        "hostname": platform.node(),
        "architecture": platform.machine(),
        "processor": platform.processor(),
        "python_version": platform.python_version(),
    }
    
    # Agregar info específica según OS
    if platform.system() == "Linux":
        try:
            with open("/etc/os-release") as f:
                for line in f:
                    if line.startswith("PRETTY_NAME"):
                        info["distro"] = line.split("=")[1].strip().strip('"')
                        break
        except:
            pass
    
    return info


print("\n=== FINGERPRINT DEL SISTEMA ===")
fp = fingerprint_sistema()
for clave, valor in fp.items():
    print(f"  {clave}: {valor}")

# ========================================
# MÓDULO SHUTIL
# ========================================

print("\n=== OPERACIONES CON ARCHIVOS (shutil) ===\n")

# Crear archivos de prueba
os.makedirs("origen", exist_ok=True)
with open("origen/archivo1.txt", "w") as f:
    f.write("Contenido del archivo 1")
with open("origen/archivo2.txt", "w") as f:
    f.write("Contenido del archivo 2")

# Copiar archivo
shutil.copy("origen/archivo1.txt", "origen/archivo1_copia.txt")
print("[+] Archivo copiado con copy()")

# Copiar preservando metadatos
shutil.copy2("origen/archivo1.txt", "origen/archivo1_copia2.txt")
print("[+] Archivo copiado con copy2() (preserva metadatos)")

# Copiar directorio completo
shutil.copytree("origen", "destino")
print("[+] Directorio copiado con copytree()")

# Mover archivo
shutil.move("destino/archivo2.txt", "destino/archivo2_movido.txt")
print("[+] Archivo movido")

# Información de disco
total, usado, libre = shutil.disk_usage("/")
print(f"\n[*] Uso de disco:")
print(f"    Total: {total // (2**30)} GB")
print(f"    Usado: {usado // (2**30)} GB")
print(f"    Libre: {libre // (2**30)} GB")

# Encontrar ejecutables
python_path = shutil.which("python3") or shutil.which("python")
print(f"\n[*] Python encontrado en: {python_path}")

nmap_path = shutil.which("nmap")
print(f"[*] Nmap encontrado en: {nmap_path or 'No instalado'}")

# Limpiar
shutil.rmtree("origen")
shutil.rmtree("destino")
print("\n[+] Directorios de prueba eliminados")</code></pre>

        <h2>3.4 Práctica: Script de Reconocimiento del Sistema</h2>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
Práctica: Script de reconocimiento básico del sistema
Recopila información de red, usuarios y procesos
"""

import os
import platform
import subprocess
import json
import socket
from datetime import datetime

def ejecutar_comando(comando, shell=False, timeout=30):
    """Ejecuta un comando y retorna la salida."""
    try:
        if isinstance(comando, str) and not shell:
            comando = comando.split()
        
        resultado = subprocess.run(
            comando,
            capture_output=True,
            text=True,
            timeout=timeout,
            shell=shell
        )
        return resultado.stdout.strip() if resultado.returncode == 0 else None
    except:
        return None


def obtener_info_sistema():
    """Recopila información básica del sistema."""
    return {
        "hostname": platform.node(),
        "sistema_operativo": platform.system(),
        "version_os": platform.release(),
        "version_detallada": platform.version(),
        "arquitectura": platform.machine(),
        "procesador": platform.processor(),
        "python_version": platform.python_version(),
    }


def obtener_info_red():
    """Recopila información de red."""
    info_red = {
        "hostname": socket.gethostname(),
        "interfaces": [],
        "dns_servers": [],
        "gateway": None
    }
    
    # Intentar obtener IP local
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        info_red["ip_local"] = s.getsockname()[0]
        s.close()
    except:
        info_red["ip_local"] = "No disponible"
    
    # Interfaces de red
    if platform.system() == "Linux":
        salida = ejecutar_comando("ip addr")
        if salida:
            lineas = salida.split('\n')
            interfaz_actual = None
            for linea in lineas:
                if ': ' in linea and not linea.startswith(' '):
                    partes = linea.split(': ')
                    if len(partes) >= 2:
                        interfaz_actual = partes[1].split('@')[0]
                elif 'inet ' in linea and interfaz_actual:
                    ip = linea.strip().split()[1]
                    info_red["interfaces"].append({
                        "nombre": interfaz_actual,
                        "ip": ip
                    })
        
        # DNS
        try:
            with open("/etc/resolv.conf") as f:
                for linea in f:
                    if linea.startswith("nameserver"):
                        info_red["dns_servers"].append(linea.split()[1])
        except:
            pass
        
        # Gateway
        salida = ejecutar_comando("ip route")
        if salida:
            for linea in salida.split('\n'):
                if linea.startswith("default"):
                    partes = linea.split()
                    if len(partes) >= 3:
                        info_red["gateway"] = partes[2]
                    break
    
    elif platform.system() == "Windows":
        salida = ejecutar_comando("ipconfig /all", shell=True)
        if salida:
            info_red["raw_output"] = salida[:1000]
    
    return info_red


def obtener_usuarios():
    """Obtiene información de usuarios del sistema."""
    usuarios = {
        "usuario_actual": os.environ.get("USER", os.environ.get("USERNAME", "Desconocido")),
        "home": os.environ.get("HOME", os.environ.get("USERPROFILE", "Desconocido")),
        "shell": os.environ.get("SHELL", "Desconocido"),
        "usuarios_sistema": []
    }
    
    if platform.system() == "Linux":
        try:
            with open("/etc/passwd") as f:
                for linea in f:
                    partes = linea.strip().split(':')
                    if len(partes) >= 7:
                        uid = int(partes[2])
                        # Solo usuarios con UID >= 1000 o root
                        if uid >= 1000 or uid == 0:
                            usuarios["usuarios_sistema"].append({
                                "nombre": partes[0],
                                "uid": uid,
                                "home": partes[5],
                                "shell": partes[6]
                            })
        except:
            pass
        
        # Usuarios logueados
        salida = ejecutar_comando("who")
        if salida:
            usuarios["usuarios_logueados"] = [
                linea.split()[0] for linea in salida.split('\n') if linea
            ]
    
    return usuarios


def obtener_procesos():
    """Obtiene lista de procesos en ejecución."""
    procesos = {
        "total": 0,
        "lista": []
    }
    
    if platform.system() == "Linux":
        salida = ejecutar_comando("ps aux")
        if salida:
            lineas = salida.split('\n')[1:]  # Saltar header
            procesos["total"] = len(lineas)
            
            # Procesos más relevantes (por uso de CPU/memoria)
            for linea in lineas[:20]:
                partes = linea.split(None, 10)
                if len(partes) >= 11:
                    procesos["lista"].append({
                        "usuario": partes[0],
                        "pid": partes[1],
                        "cpu": partes[2],
                        "memoria": partes[3],
                        "comando": partes[10][:50]
                    })
    
    elif platform.system() == "Windows":
        salida = ejecutar_comando("tasklist", shell=True)
        if salida:
            lineas = salida.split('\n')[3:]
            procesos["total"] = len([l for l in lineas if l.strip()])
    
    return procesos


def obtener_puertos_abiertos():
    """Obtiene puertos abiertos/escuchando."""
    puertos = []
    
    if platform.system() == "Linux":
        salida = ejecutar_comando("ss -tuln")
        if salida:
            for linea in salida.split('\n')[1:]:
                partes = linea.split()
                if len(partes) >= 5:
                    estado = partes[1] if len(partes) > 1 else "UNKNOWN"
                    direccion = partes[4] if len(partes) > 4 else ""
                    if "LISTEN" in linea or estado == "UNCONN":
                        puertos.append({
                            "protocolo": partes[0],
                            "direccion": direccion,
                            "estado": estado
                        })
    
    elif platform.system() == "Windows":
        salida = ejecutar_comando("netstat -an", shell=True)
        if salida:
            for linea in salida.split('\n'):
                if "LISTENING" in linea or "ESTABLISHED" in linea:
                    partes = linea.split()
                    if len(partes) >= 4:
                        puertos.append({
                            "protocolo": partes[0],
                            "local": partes[1],
                            "estado": partes[3] if len(partes) > 3 else ""
                        })
    
    return puertos[:20]  # Limitar a 20


def verificar_herramientas():
    """Verifica qué herramientas de seguridad están instaladas."""
    import shutil
    
    herramientas = [
        "nmap", "nikto", "dirb", "gobuster", "hydra",
        "john", "hashcat", "sqlmap", "metasploit",
        "wireshark", "tcpdump", "netcat", "nc",
        "curl", "wget", "ssh", "openssl"
    ]
    
    instaladas = {}
    for herramienta in herramientas:
        ruta = shutil.which(herramienta)
        instaladas[herramienta] = ruta if ruta else False
    
    return instaladas


def generar_reporte():
    """Genera el reporte completo de reconocimiento."""
    print("=" * 60)
    print("   REPORTE DE RECONOCIMIENTO DEL SISTEMA")
    print(f"   Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)
    
    # Sistema
    print("\n[*] INFORMACIÓN DEL SISTEMA:")
    sistema = obtener_info_sistema()
    for clave, valor in sistema.items():
        print(f"    {clave}: {valor}")
    
    # Red
    print("\n[*] INFORMACIÓN DE RED:")
    red = obtener_info_red()
    print(f"    IP Local: {red.get('ip_local', 'N/A')}")
    print(f"    Gateway: {red.get('gateway', 'N/A')}")
    print(f"    DNS: {', '.join(red.get('dns_servers', [])) or 'N/A'}")
    
    if red.get("interfaces"):
        print("    Interfaces:")
        for iface in red["interfaces"]:
            print(f"      - {iface['nombre']}: {iface['ip']}")
    
    # Usuarios
    print("\n[*] USUARIOS:")
    usuarios = obtener_usuarios()
    print(f"    Usuario actual: {usuarios['usuario_actual']}")
    print(f"    Home: {usuarios['home']}")
    print(f"    Shell: {usuarios['shell']}")
    
    if usuarios.get("usuarios_logueados"):
        print(f"    Usuarios logueados: {', '.join(usuarios['usuarios_logueados'])}")
    
    # Procesos
    print("\n[*] PROCESOS:")
    procesos = obtener_procesos()
    print(f"    Total procesos: {procesos['total']}")
    
    # Puertos
    print("\n[*] PUERTOS EN ESCUCHA:")
    puertos = obtener_puertos_abiertos()
    for puerto in puertos[:10]:
        print(f"    {puerto.get('protocolo', 'N/A')}: {puerto.get('direccion', puerto.get('local', 'N/A'))}")
    
    # Herramientas
    print("\n[*] HERRAMIENTAS DE SEGURIDAD:")
    herramientas = verificar_herramientas()
    instaladas = [h for h, r in herramientas.items() if r]
    no_instaladas = [h for h, r in herramientas.items() if not r]
    
    print(f"    Instaladas: {', '.join(instaladas) if instaladas else 'Ninguna'}")
    print(f"    No encontradas: {', '.join(no_instaladas[:5])}...")
    
    print("\n" + "=" * 60)
    
    # Exportar a JSON
    reporte = {
        "fecha": datetime.now().isoformat(),
        "sistema": sistema,
        "red": red,
        "usuarios": usuarios,
        "procesos": procesos,
        "puertos": puertos,
        "herramientas": herramientas
    }
    
    with open("reporte_sistema.json", "w") as f:
        json.dump(reporte, f, indent=4, default=str)
    
    print("[+] Reporte exportado a: reporte_sistema.json")
    
    return reporte


# ========================================
# EJECUTAR
# ========================================

if __name__ == "__main__":
    reporte = generar_reporte()</code></pre>

        <h2>Ejercicios para Practicar</h2>

        <ol>
            <li><strong>Analizador de logs Apache/Nginx</strong>: Parsear logs de acceso web, extraer IPs, URLs, códigos de respuesta y detectar patrones sospechosos.</li>
            <li><strong>Buscador de archivos sensibles</strong>: Crear un script que recorra directorios buscando archivos con extensiones sensibles (.key, .pem, .env, .conf).</li>
            <li><strong>Extractor de metadatos</strong>: Leer archivos y extraer información como fechas de modificación, permisos, tamaño.</li>
            <li><strong>Validador de configuraciones</strong>: Leer archivos de configuración (SSH, Apache) y verificar opciones de seguridad.</li>
            <li><strong>Monitor de procesos</strong>: Script que monitorea procesos nuevos y genera alertas si detecta nombres sospechosos.</li>
        </ol>

    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>